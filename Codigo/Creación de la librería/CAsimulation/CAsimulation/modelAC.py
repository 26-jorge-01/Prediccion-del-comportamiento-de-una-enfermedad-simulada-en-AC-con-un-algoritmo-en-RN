# -*- coding: utf-8 -*-
"""Epidemilogical_Modeling_in_CelularAutomata.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ncWETR4AvCcrKqLDQACl7-ONeuo1gOF_

# Epidemilogical Modeling in CelularAutomata

## preliminary
"""

!pip install opencv-python

!pip install opencv-contrib-python

import numpy as np
import matplotlib.pyplot as plt
import cv2
import string
import pandas as pd
import glob
import random 
from skimage.color import rgb2gray
import seaborn as sns
import scipy.integrate as spi
import math 
from sklearn import linear_model
from sklearn.metrics import mean_squared_error, r2_score

def spline3(A):     #spline cubico para la lista de coordenadas A 
    n = len(A) 
    a = []; h = []; x = []; y = []*(n-1); C = [0]*n
    alpha = []
    l = [1]
    B = [0] 
    g = [0]; gn = 0
    spline = []
    for i in range(n):
        a.append(A[i][1])
    for i in range(n-1):
        xh = A[i+1][0]-A[i][0]
        h.append(xh)
    for i in range(1, n-1):
        xa = (3/h[i])*(a[i+1]-a[i])-(3/h[i-1])*(a[i]-a[i-1])
        alpha.append(xa)
    for i in range(1, n-1):
        xl = 2*(A[i+1][0]-A[i-1][0])-h[i-1]*B[i-1]
        l.append(xl)
        xb = h[i]/l[i]
        B.append(xb)
        xg = (alpha[i-1]-h[i-1]*g[i-1])/l[i]
        g.append(xg)
    l.append(1)
    g.append(0)
    for i in range(n-1):
        j = (n-1)-(i+1)
        xC = g[j]-B[j]*C[j+1]
        C[j] = xC
        xy = ((a[j+1]-a[j])/h[j])-(h[j]/3)*(C[j+1]+2*C[j])
        y.append(xy)
        xx = (C[j+1]-C[j])/(3*h[j])
        x.append(xx)
    for i in range(n-1):
        j=(n-1)-(i+1)
        S3 = [a[i],y[j],C[i],x[j]]
        spline.append(S3)
    SC=np.array(spline)
    return SC

def one_function_graph(A,texto): #Grafica del spline cubico para la lista de coordenadas A
    cond=[]            
    funcion=[]
    SP=spline3(A)
    cond=[]
    funcion=[]
    x=[]
    y=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SP[i,0]+SP[i,1]*(xa-A[i,0])+SP[i,2]*(xa-A[i,0])**2+SP[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
  
    texto=str(texto)
    plt.plot(x, y, c='blue')
    plt.title(texto)
    plt.xlabel('Tiempo')
    plt.show()

def one_state_graph(A,texto): #Grafica del spline cubico para la lista de coordenadas A
    cond=[]            
    funcion=[]
    SP=spline3(A)
    cond=[]
    funcion=[]
    x=[]
    y=[]; l=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SP[i,0]+SP[i,1]*(xa-A[i,0])+SP[i,2]*(xa-A[i,0])**2+SP[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
    
    texto=str(texto)
    plt.plot(x, x**0, 'k--')
    plt.plot(x, y, c='blue')
    plt.title(texto)
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def two_states_graph(A,B,texto1, texto2, titulo): #Grafica del spline cubico para las listas de coordenadas A y B
    cond=[]             
    funcion=[]
    SA=spline3(A)
    SB=spline3(B)
    cond=[]
    funcion=[]
    x=[]
    y=[]
    z=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
  
    texto1=str(texto1); texto2=str(texto2);  titulo=str(titulo)
    plt.plot(x, x**0, 'k--')
    plt.plot(x, y, c='y', label=texto1)
    plt.plot(x, z, c='r', label=texto2)
    plt.legend(loc=0)
    plt.title(titulo)
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def three_states_graph(A,B,C,texto1,texto2,texto3,titulo): #Grafica del spline cubico para las listas de coordenadas A,B y C
    cond=[]             
    funcion=[]
    SA=spline3(A)
    SB=spline3(B)
    SC=spline3(C)
    cond=[]
    funcion=[]
    x=[]
    y=[]
    z=[]
    w=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
  
    texto1=str(texto1); texto2=str(texto2); texto3=str(texto3);  titulo=str(titulo)
    plt.plot(x, y, c='y', label=texto1)
    plt.plot(x, z, c='g', label=texto2)
    plt.plot(x, w, c='r', label=texto3)
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title(titulo)
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def distribution_graph(A,B,C,D,E,F,G,H,I,J):  #Grafica de variación presente en la condición inicial
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C); SD=spline3(D); SE=spline3(E)
    SF=spline3(F); SG=spline3(G); SH=spline3(H); SI=spline3(I); SJ=spline3(J)
    x=[]; y=[]; z=[]; w=[]; t=[]; a=[]
    b=[]; c=[]; d=[]; e=[]; f=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
        ta=SD[i,0]+SD[i,1]*(xa-D[i,0])+SD[i,2]*(xa-D[i,0])**2+SD[i,3]*(xa-D[i,0])**3
        t=np.concatenate((t,ta))
        aa=SE[i,0]+SE[i,1]*(xa-E[i,0])+SE[i,2]*(xa-E[i,0])**2+SE[i,3]*(xa-E[i,0])**3
        a=np.concatenate((a,aa))
        ba=SF[i,0]+SF[i,1]*(xa-F[i,0])+SF[i,2]*(xa-F[i,0])**2+SF[i,3]*(xa-F[i,0])**3
        b=np.concatenate((b,ba))
        ca=SG[i,0]+SG[i,1]*(xa-G[i,0])+SG[i,2]*(xa-G[i,0])**2+SG[i,3]*(xa-G[i,0])**3
        c=np.concatenate((c,ca))
        da=SH[i,0]+SH[i,1]*(xa-H[i,0])+SH[i,2]*(xa-H[i,0])**2+SH[i,3]*(xa-H[i,0])**3
        d=np.concatenate((d,da))
        ea=SI[i,0]+SI[i,1]*(xa-I[i,0])+SI[i,2]*(xa-I[i,0])**2+SI[i,3]*(xa-I[i,0])**3
        e=np.concatenate((e,ea))
        fa=SJ[i,0]+SJ[i,1]*(xa-J[i,0])+SJ[i,2]*(xa-J[i,0])**2+SJ[i,3]*(xa-J[i,0])**3
        f=np.concatenate((f,fa))
  
    plt.plot(x, y, c='g', label="noroeste")
    plt.plot(x, z, c='gold', label="norte")
    plt.plot(x, w, c='peru', label="noreste")
    plt.plot(x, t, c='c', label="oeste")
    plt.plot(x, a, c='magenta', label="central")
    plt.plot(x, b, c='darkorange', label="este")
    plt.plot(x, c, c='royalblue', label="suroeste")
    plt.plot(x, d, c='mediumorchid', label="sur")
    plt.plot(x, e, c='r', label="sureste")
    plt.plot(x, f, c='lime', label="aleatorio")
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title('Condición inicial')
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def scales_graph(A,B,C,D,E): #Gráfica de cambios de escalas
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C); SD=spline3(D); SE=spline3(E)
    x=[]; y=[]; z=[]; w=[]; t=[]; l=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
        ta=SD[i,0]+SD[i,1]*(xa-D[i,0])+SD[i,2]*(xa-D[i,0])**2+SD[i,3]*(xa-D[i,0])**3
        t=np.concatenate((t,ta))
        la=SE[i,0]+SE[i,1]*(xa-E[i,0])+SE[i,2]*(xa-E[i,0])**2+SE[i,3]*(xa-E[i,0])**3
        l=np.concatenate((l,la))
  
    plt.plot(x, y, c='purple', label="escala 1")
    plt.plot(x, z, c='steelblue', label="escala 2")
    plt.plot(x, w, c='darkorange', label="escala 3")
    plt.plot(x, t, c='firebrick', label="escala 4")
    plt.plot(x, l, c='seagreen', label="escala 5")
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title('Cambio de escalas')
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def systems_graph(A,B,C,D,E,F,G): #Gráfica de cambios de escalas
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C); SD=spline3(D); SE=spline3(E); SF=spline3(F); SG=spline3(G)
    x=[]; y=[]; z=[]; w=[]; t=[]; l=[]; o=[]; p=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
        ta=SD[i,0]+SD[i,1]*(xa-D[i,0])+SD[i,2]*(xa-D[i,0])**2+SD[i,3]*(xa-D[i,0])**3
        t=np.concatenate((t,ta))
        la=SE[i,0]+SE[i,1]*(xa-E[i,0])+SE[i,2]*(xa-E[i,0])**2+SE[i,3]*(xa-E[i,0])**3
        l=np.concatenate((l,la))
        oa=SF[i,0]+SF[i,1]*(xa-F[i,0])+SF[i,2]*(xa-F[i,0])**2+SF[i,3]*(xa-F[i,0])**3
        o=np.concatenate((o,oa))
        pa=SG[i,0]+SG[i,1]*(xa-G[i,0])+SG[i,2]*(xa-G[i,0])**2+SG[i,3]*(xa-G[i,0])**3
        p=np.concatenate((p,pa))
        
    plt.plot(x, y, c='purple', label="Linea")
    plt.plot(x, z, c='steelblue', label="Cuadrado")
    plt.plot(x, w, c='darkorange', label="Rectángulo")
    plt.plot(x, t, c='firebrick', label="Rombo")
    plt.plot(x, l, c='seagreen', label="Triángulo")
    plt.plot(x, l, c='cyan', label="Caso #1")
    plt.plot(x, l, c='orangered', label="Caso #2")
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title('Comparación entre sistemas')
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def scales_difference_graph(A,B,C,D): #Gráfica de cambios de escalas
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C); SD=spline3(D)
    x=[]; y=[]; z=[]; w=[]; t=[]; l=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
        ta=SD[i,0]+SD[i,1]*(xa-D[i,0])+SD[i,2]*(xa-D[i,0])**2+SD[i,3]*(xa-D[i,0])**3
        t=np.concatenate((t,ta))
  
    plt.plot(x, y, c='purple', label="|E5-E1|")
    plt.plot(x, z, c='steelblue', label="|E5-E2|")
    plt.plot(x, w, c='darkorange', label="|E5-E3|")
    plt.plot(x, t, c='firebrick', label="|E5-E4|")
    plt.legend(loc=0)
    plt.title('Diferencias')
    plt.xlabel('Tiempo')
    plt.show()

"""## Introducción

Los modelos de tipo SIR son objeto de estudio en muchos campos de la ciencia, los comportamientos de las personas caracterizadas por un estado se describen para estos modelos. Encontramos, en el contexto de estos modelos de tres estados generales, susceptibles, infectados y recuperados.

Existen muchas variaciones con respecto al modelo SIR, consideremos, por ejemplo, el modelo SIS, estos modelos describen interacciones entre dos estados, susceptibles e infectados o, por otro lado, el modelo SEIR, podemos describir interacciones entre cuatro estados para cada individuo en estos modelos, el individuo puede ser "expuesto" a la enfermedad, pero no infecta a otros individuos [2].

Debemos tener en cuenta que si el propósito es acercarse a la realidad, lo mejor sería incluir un nuevo parámetro y un nuevo estado, en nuestro estudio es de vital importancia incluir la tasa de natalidad y la tasa de mortalidad. Utilizamos autómatas celulares para modelar las interacciones entre estados, estos modelos matemáticos permitieron describir el comportamiento de una enfermedad de acuerdo con la ubicación inicial de los pacientes infectados. También podemos describir la evolución de la enfermedad introduciendo una cura en la población en el tiempo $t$.

Al crear reglas de tipo totalista para modelar la transición entre estados, consideramos también el uso de cada individuo, además se analizaron los cambios presentados por la topología del vecindario. En última instancia, usar Python para simular la evolución de una enfermedad en Bototá dados cuatro estados iniciales posibles para cada individuo

## Modelo $SIS$ en EDO's

Los diversos estados del modelo serán:

$$\begin{array}{ccccc}
    & \small{\beta SI} & & \small{\alpha I} & \\
    S & \longrightarrow & I & \longrightarrow & S
\end{array}$$

Para formular el modelo epidemiológico usaremos las derivadas para expresar los cambios en los estados del modelo, así el sistema de ecuaciones es precisamente 

\begin{align*}
    S'&=-\beta SI+\alpha SI\\
    I'&=\beta SI-\alpha SI
\end{align*}

Suponemos que se cumplen las condiciones iniciales:
$$\begin{array}{ccc}
    S(0)=S_0\geq0 & I(0)=I_0\geq0 & S(t)+I(t)=1
\end{array}$$

Para este modelo, como se vio en la sección anterior, $b(a)=\beta$ y además $F(a)=e^{-\alpha\beta}$ ya que $p(a)=\alpha$ (tasa de recuperación), por lo tanto de la formulación de $R_0$ tenemos que

$$R_0=\frac{\beta}{\alpha}$$

Como se vio en [2], si $R_0<1$ la enfermedad acaba desapareciendo y si por otro lado $R_0>1$ la enfermedad puede ser endémica; al resolver por el método de Euler el sistema de ecuaciones tenemos que

\begin{align}
S_{n+1}&=S_n+h\cdot(-\beta S_n I_n+\alpha I_n)\\
I_{n+1}&=I_n+h\cdot(\beta S_n\cdot I_n-\alpha I_n)
\end{align}
"""

N=1
'''time step'''
TS=1.0 
ND=40.0 #tiempo de analisis de la enfermedad (en meses)
S0=0.9
I0=0.1
mu=1/75
INPUT = (S0, I0)

def diff_SIS(INP,t):  
    Y=np.zeros((2))
    V = INP
    '''Las ecuaciones diferenciales'''
    Y[0] = -b*V[0]*V[1]+a*V[1]+mu-mu*V[0]
    Y[1] = b*V[0]*V[1]-a*V[1]-mu*V[1]
    return Y

def grafsis(ND,TS,INP):
    t_start = 0.0; t_end = ND; t_inc = TS
    t_range = np.arange(t_start, t_end+t_inc, t_inc)
    RES1 = spi.odeint(diff_SIS,INPUT,t_range)
    plt.plot(RES1[:,0]*N, '-y', label='Susceptibles')
    plt.plot(RES1[:,1]*N, '-r', label='Infectados')
    plt.legend(loc=0)
    plt.title('Modelo SIS') 
    plt.xlabel('Tiempo')
    plt.ylim(0, 1)
    plt.savefig('sirpy')

a=0.2; b=0.5

grafsis(ND,TS,INPUT)

a=0.2; b=0.05

grafsis(ND,TS,INPUT)

"""## Modelo $SIR$ en EDO’s

Las interacciones entre los estados del modelo se describen en el siguiente diagrama

![texto alternativo](https://mail.google.com/mail/u/0?ui=2&ik=b13f0b563c&attid=0.2&permmsgid=msg-a:r1157691735925474387&th=17096ce2cdeb8e8d&view=att&disp=safe&realattid=f_k797su591)

Las ecuaciones (1) describen el cambio en las poblaciones, identificando los estados susceptibles, infectados y recuperados con $S$, $I$ y $R$ respectivamente, la fecha de recuperación de los parámetros $\alpha$, tasa de infección $\beta$ y tasa de mortalidad por enfermedad $\theta$ están determinados por la enfermedad, por otro lado, la tasa de natalidad / mortalidad $\mu$ Es estimado por la población.

\begin{equation}
\left\{
\begin{array}{ccc}
    S' & = & -\beta SI+\mu(1-S)\\
    I' & = & \beta SI-\mu I-\alpha I\\
    R' & = & (1-\theta)\alpha I-\mu R
\end{array}\right.
\end{equation}

Usando python podemos describir las soluciones de este modelo, a continuación hay dos enfermedades que simulan condiciones diferenciales para $R_0$ [1], en ambas simulaciones fue considerado $\mu=1/(75∗12)$, lo que significa que la tasa de natalidad individual es de 75 años

*   **Disease A** has infection and recovery rate $\beta = 0.05$, $\alpha= 0.2$ by month, respectively. It was considerate that $40\%$ the population infected, death by disease.
*   **Disease B** has the same disease conditions A but, changing the infection rate to $\beta = 0.5$.

Como en [1], estudiamos ambas enfermedades en un período de 150 años, con condiciones iniciales $S(0)=0.4$, $I(0)=0.1$ y $R(0)=0$.

Como se define en [1], el indicador $R_0=\frac{\beta}{\alpha+\mu}$ para la enfermedad A es $0,2486<1$ y para la enfermedad B es $2,4862>1$, esto implica que la enfermedad A desaparecerá y, por otro lado, el comportamiento de la enfermedad B es "estable" con el tiempo.
"""

N=1
beta1=0.05 #tasa de infeccion 1
beta2=0.5 #tasa de infeccion 2
alpha=0.2 #tasa de recuperacion
mu=1/27375 #tasa de natalidad ESTA ES LA PARTE QUE NO VA
theta=0 #muerte por infeccion
'''time step'''
TS=1.0 
ND=100.0 #tiempo de analisis de la enfermedad (en meses)
S0=0.9
I0=0.1
INPUT = (S0, I0, 0.0)

def diff_SIR1(INP,t):  
    Y=np.zeros((3))
    V = INP
    '''Las ecuaciones diferenciales'''
    Y[0] = -beta1*V[0]*V[1]+mu*(1-V[0])
    Y[1] = beta1*V[0]*V[1]-mu*V[1]-alpha*V[1]
    Y[2] = (1-theta)*alpha*V[1]-mu*V[2]
    return Y

def diff_SIR2(INP,t):  
    Y=np.zeros((3))
    V = INP
    '''Las ecuaciones diferenciales'''
    Y[0] = -beta2*V[0]*V[1]+mu*(1-V[0])
    Y[1] = beta2*V[0]*V[1]-mu*V[1]-alpha*V[1]
    Y[2] = (1-theta)*alpha*V[1]-mu*V[2]
    return Y

t_start = 0.0; t_end = ND; t_inc = TS
t_range = np.arange(t_start, t_end+t_inc, t_inc)
RES1 = spi.odeint(diff_SIR1,INPUT,t_range)

t_start = 0.0; t_end = ND; t_inc = TS
t_range = np.arange(t_start, t_end+t_inc, t_inc)
RES2 = spi.odeint(diff_SIR2,INPUT,t_range)

plt.plot(RES1[:,0]*N, '-y', label='Susceptibles')
plt.plot(RES1[:,2]*N, '-g', label='Recuperados')
plt.plot(RES1[:,1]*N, '-r', label='Infectados')
plt.legend(loc=0)
plt.title('Modelo SIR')
plt.xlabel('Tiempo')
plt.ylim(0, 1)
plt.savefig('sirpy')

plt.plot(RES2[:,0]*N, '-y', label='Susceptibles')
plt.plot(RES2[:,2]*N, '-g', label='Recuperados')
plt.plot(RES2[:,1]*N, '-r', label='Infectados')
plt.legend(loc=0)
plt.title('Modelo SIR')
plt.xlabel('Tiempo')
plt.ylim(0, 1)
plt.savefig('sirpy1')

"""## Automatas Celulares

Los autómatas celulares son un modelo matemático que permite describir un sistema dinámico, están compuestos por un conjunto de celdas que adquieren diferentes estados o valores. El estado de la celda se altera en mediciones de tiempo discretas, a veces esta transición entre estados se ve afectada debido al comportamiento en la vecindad de la celda y los estados de sus celdas vecinas están determinados por una expresión matemática que se conoce como regla de transición local.

A continuación definiremos los elementos básicos que posee un AC n-dimensional. 

**Definición:** Conoceremos por arreglo regular al espacio n-dimensional de la evolución, cada división homogenea de la disposición puede ser llamada celda, célula o agente. 

**Definición:** Definimos el conjunto de estados $\sum$ como el conjunto de posibles estados que pueda tomar un agente en el arreglo regular. Note que necesariamente el conjunto $\sum$ es finito.

**Notación:** Denote $C^t(X)$ al conjunto de agentes que poseen un estado $X$ en el tiempo $t$.

**Definición:** Conoceremos por configuración inicial al arreglo regular en el tiempo $t=0$, cada célula presente en este arreglo debe tomar un estado del conjunto $\sum$.

**Definición:** Defina el conjunto de células que se consideran adyacentes a una dada, así como la posición relativa respecto a ella como una vecindad.

**Definición:** Conoceremos por función local a la regla de evolución que determina el comportamiento del autómata celular, esta función asigna a cada agente un elemento del conjunto de estados en base a una condición dada y al comportamiento en su vecindad.

**Definición:** La evolución de cada vecindad en el sistema se realiza de manera simultanea, de esta manera cada arreglo generado al aplicar la función local sobre cada vecindad se conocerá como estado del sistema en el tiempo $t$.

Es importante resaltar la complejidad que se logra con una AC, esto se debe al comportamiento vecino de cada celda, ya que el siguiente estado de cada celda evoluciona en función del estado anterior y de sus vecinos (es decir, el estado 2 surge del estado 1 y 3 de 2, etc.), tiene que ser un sistema dinámico y con un comportamiento muy difícil de predecir. [3]

### AC 2-dimensional

En dos dimensiones tenemos un arreglo definido por parejas ordenadas $\mathbb{Z}\textrm{ x }\mathbb{Z}$. Denotaremos por $x_{ij}^{t}$ a la célula en la fila $i$, columna $j$ en la configuración $t$.

Para el caso de AC en dos dimensiones, encontramos una gran variedad de vecindarios, sin embargo, para los intereses de investigación analizamos la vecindad de Moore, que consideran los vecinos diagonales y ortogonales.

![texto alternativo](https://docs.google.com/drawings/d/e/2PACX-1vQ68qQEzqQf9RH3dNxVmIXYT9e0MvKKLEvPHR2gfv5o4xxBwLpG9dSQvCr0HrFAILbpx-3Rqu6F-J-0/pub?w=947&h=343)

Para implementar este tipo de vecindad en nuestra simulación sera necesario generar una vecindad para cada celula $x_{ij}$ ubicada en el nuestro arreglo regular.
"""

def array_generator(K,i,j):  #Se genera la veindad para la célula en la posición i,j en el arreglo regular (Ar)
    A = np.zeros((3,3))      #La vecindad debe tener 8 agentes y una célula central
    A[0][0] = K[i-1][j-1]    #Vecino en la possición i-1,j-1
    A[0][1] = K[i-1][j]      #Vecino en la possición i-1,j
    A[0][2] = K[i-1][j+1]    #Vecino en la possición i-1,j+1
    A[1][0] = K[i][j-1]      #Vecino en la possición i,j-1
    A[1][1] = K[i][j]        #Célula central
    A[1][2] = K[i][j+1]      #Vecino en la possición i,j+1
    A[2][0] = K[i+1][j-1]    #Vecino en la possición i+1,j-1
    A[2][1] = K[i+1][j]      #Vecino en la possición i+1,j
    A[2][2] = K[i+1][j+1]    #Vecino en la possición i+1,j+1
    return A                 #Vecindad del agente en la posición i,j

"""Una propiedad particular que adquiere cada agente es que en el instante $t$ solamente puede adquirir un estado de $\sum$, dicho de otra forma, $\sum$ genera una partición sobre el estado del sistema en cada tiempo $t$, de esta manera el conjunto $\left(\mathbb{Z}\textrm{ x }\mathbb{Z}\right)/\sum$ está bien definido para cada $t$, a partir de esta observación se define de manera directa el conjunto de agentes pertenecientes al estado $X$.

**Definición:** Definimos el conjunto $C^t(X)\in\left(\mathbb{Z}\textrm{ x }\mathbb{Z}\right)/\sum$ como el conjunto de agentes que poseen un estado $X$ en el tiempo $t$.

*Observación:* Note que los elementos del conjunto $C^t(X)$ son las posiciones de los individuos que poseen el estado $X$ en el tiempo $t$.

Para los objetivos de este estudio definiremos las isguientes funciones que generan los conjuntos $C^t(S)$ y $C^t(I)$.
"""

def vector_S(A):               #Definición del conjunto de posiciones del estado S en el sistema A
    n,m=A.shape                #Consideramos la dimensión del sistema A
    S=[]                       #S guardará las posiciones de los individuos susceptibles
    for i in range(n):         #para i en n filas
        for j in range(m):     #para j en m columnas
            if A[i][j]==0:     #Verifique si el individuo en la posición i,j es susceptible
                S.append([i,j])#Si es verdadero añanda la posición del individuo a la lista S
    return S                   #Retorne la lista de posiciones de los individuos susceptibles

def vector_I(A):               #Definición del conjunto de posiciones del estado I en el sistema A
    n,m=A.shape                #Consideramos la dimensión del sistema A
    I=[]                       #I guardará las posiciones de los individuos infectados
    for i in range(n):         #para i en n filas
        for j in range(m):     #para j en m columnas
            if A[i][j]==1:     #Verifique si el individuo en la posición i,j esta infectado
                I.append([i,j])#Si es verdadero añanda la posición del individuo a la lista I
    return I                   #Retorne la lista de posiciones de los individuos infectados

"""**Notación:** Denote por $V_{ij}$ a la vecindad de Moore del agente en la posición $i,j$.

Por otro lado, observe que a medida que aumentamos la dimensión de la AC, debemos tener en cuenta que el número de vecindades mayores y tratar de representar la regla de evolución se convierte en un problema de simplificar el número de variables para la función $\phi$ (función de evolución).

### Reglas totalísticas

En las reglas totalistas se agregan los valores de los elementos que forman la vecindad, según la regla se pueden asignar valores o estados.

$$\phi(a,b,c)=\tau(a+b+c)=K\in\sum$$

Estos valores determinan el comportamiento de los vecindarios que corresponde al mismo agregado en el período consecutivo en el que se aplica la regla totalista.

### Reglas semi-totalísticas

En el caso de las reglas semi-totalistas, también se hace una suma, pero esto solo se realiza con los vecinos independientemente de la celda central. La celda central está considerando solo para determinar bajo qué condición se debe evaluar la suma

\begin{equation}
    \phi(x_0,x_1,\cdots,x_V)=\left\{\begin{array}{ccc}
    1 & \textrm{si } & \left\{\begin{array}{ccc}
        x_0=0 & \textrm{y } & B_{\textrm{min}}\leq\sum_{i=1}^{V}x_i\leq B_{\textrm{max}} \\
        x_0=1 & \textrm{y } & S_{\textrm{min}}\leq\sum_{i=1}^{V}x_i\leq S_{\textrm{max}}
    \end{array}\right.\\
    0 & \textrm{en otro caso}
\end{array}\right.
\end{equation}

En la ecuación 2 tenemos el caso binario donde $x_0$ representa la célula central $x_{i,j}$ y las variables $x_1,···,x_V$ son el numero de vecinos. Dependiendo del valor de la celda central, los sumis condicionados a un par de parámetros diferente. En la ecuación 2 los parámetros $B_{min}$ y $B_{max}$ se evalúa si la celda central tiene valor 0. Por otro lado, si tiene valor 1, entonces se evalúan los parámetros. $S_{min}$ y $S_{max}$.[4]

## Modelos epidemiológicos en AC

Para comenzar con nuestro estudio en los modelos epidemiológicos usando AC, es importante definir los estados modelo. Trabajaremos con estados susceptibles $S$, infectados $I$, recuperados $R$ y muertos $D$, adicionalmente incluiremos el estado vacio $V$ en nuestro modelo, esto permitirá realizar un análisis en el cambio de la topologia de la vecindad de Moore, está noción se explicara de manera mas precisa en secciones posteriores. De esta manera, el conjunto de estados estara dado por $\sum=\{S,I,R,D,V\}$. De esta forma, las posibles variaciones en los vecindarios sin tomar en cuanta el estado vacio, se mostrarán en la figura 4:

![texto alternativo](https://docs.google.com/drawings/d/e/2PACX-1vRiC4TyqdvOpkwatn_buo6O0SiWdXydLOLwJKAGpLcBrx01SB8Fy0tnsJ7T6pA3zafQgLRCOQSqi4w5/pub?w=959&h=486)

Representaremos con los colores amarillo, rojo, verde y blanco los estados $ S $, $ I $, $ R $ y $ D $ respectivamente. En la figura anterior se muestran unicamente uno de los casos posibles de permutación por cada estado de interacción la vecindad. Dicho esto, estableceremos algunas pautas para construir la regla de evolución del modelo SIR:

### La regla base de evolución.

Para poder plantear nuestra simulación haremos uso de las reglas totalísticas; identificaremos de manera numérica los estados susceptible, infectado, recuperado con los valores $0$, $1$, $2$ y $3$ respectivamente. Adicionalmente identificaremos los lugares vacios con -1. Teniendo esto en cuenta, debemos incluir algunas notaciones previas para poder definir las reglas de comportamiento que tendrán los agentes celulares.

**Notación** Denote por $N_{ij}^t(X)$ al cardinal del conjunto $C^t(X)\cap V_{ij}$, es decir, $N_{ij}^t(X)$ será la cantidad de individuos que poseen el estado $X$ en la vecindad del agente en la posicióón $i,j$ en el tiempo $t$. De manera similar denote $N^t(X)$ como el cardinal del conjunto $C^t(X)$.
"""

def sumaS(V):                 #Cantidad de individuos susceptibles en la vecindad V
    sumaS=0                   #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(3):        #Tres filas en la vecindad de Moore
        for j in range(3):    #Tres columnas en la vecindad de Moore
            if V[i][j]==0:    #Para cada individuo se verifica si está identificado con el estado S
                sumaS=sumaS+1 #Si es verdadero, aumente en uno el contador de susceptibles
    if V[1][1]==0:            #La célula central no se considera en el conteo  
        sumaS=sumaS-1         #Si la célula central es susceptible se elimina de la suma
    return sumaS              #cantidad de suscptibles en la vecindad V

def sumaI(V):                 #Cantidad de individuos infectados en la vecindad V
    sumaI=0                   #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(3):        #Tres filas en la vecindad de Moore
        for j in range(3):    #Tres columnas en la vecindad de Moore
            if V[i][j]==1:    #Para cada individuo se verifica si está identificado con el estado I
                sumaI=sumaI+1 #Si es verdadero, aumente en uno el contador de infectados
    if V[1][1]==1:            #La célula central no se considera en el conteo  
        sumaI=sumaI-1         #Si la célula central esta infectada se elimina de la suma
    return sumaI              #cantidad de infectados en la vecindad V

def sumaR(V):                 #Cantidad de individuos recuperados en la vecindad V
    sumaR=0                   #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(3):        #Tres filas en la vecindad de Moore
        for j in range(3):    #Tres columnas en la vecindad de Moore
            if V[i][j]==2:    #Para cada individuo se verifica si está identificado con el estado R
                sumaR=sumaR+1 #Si es verdadero, aumente en uno el contador de recuperados
    if V[1][1]==2:            #La célula central no se considera en el conteo  
        sumaR=sumaR-1         #Si la célula central esta recuperada se elimina de la suma
    return sumaR              #cantidad de recuperados en la vecindad V

def sumaV(V):                 #Cantidad de espacios vacios en la vecindad V
    sumaV=0                   #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(3):        #Tres filas en la vecindad de Moore
        for j in range(3):    #Tres columnas en la vecindad de Moore
            if V[i][j]==-1:   #Para cada espacio se verifica si está identificado con el estado V
                sumaV=sumaV+1 #Si es verdadero, aumente en uno el contador de recuperados
    if V[1][1]==-1:           #La célula central no se considera en el conteo  
        sumaV=sumaV-1         #Si la célula central no está se elimina de la suma
    return sumaV              #cantidad de espacios vacios en la vecindad V

def count_S(A):             #Cantidad de individuos que poseen el estado S en el arreglo A
    n,m=A.shape             #Dim(A)=nm
    suma=0                  #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(n):      #n filas del arreglo A
        for j in range(m):  #m columnas del arreglo A
            if A[i][j]==0:  #Para cada espacio se verifica si está identificado con el estado S
                suma=suma+1 #Si es verdadero, aumente en uno el contador de susceptibles
    return int(suma)        #cantidad de individuos susceptibles en el arreglo A

def count_I(A):             #Cantidad de individuos que poseen el estado I en el arreglo A
    n,m=A.shape             #Dim(A)=nm
    suma=0                  #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(n):      #n filas del arreglo A
        for j in range(m):  #m columnas del arreglo A
            if A[i][j]==1:  #Para cada espacio se verifica si está identificado con el estado I
                suma=suma+1 #Si es verdadero, aumente en uno el contador de infectados
    return int(suma)        #cantidad de individuos infectados en el arreglo A

def count_R(A):             #Cantidad de individuos que poseen el estado R en el arreglo A
    n,m=A.shape             #Dim(A)=nm
    suma=0                  #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(n):      #n filas del arreglo A
        for j in range(m):  #m columnas del arreglo A
            if A[i][j]==2:  #Para cada espacio se verifica si está identificado con el estado R
                suma=suma+1 #Si es verdadero, aumente en uno el contador de recuperados
    return int(suma)        #cantidad de individuos recuperados en el arreglo A

def count_D(A):             #Cantidad de individuos que poseen el estado D en el arreglo A
    n,m=A.shape             #Dim(A)=nm
    suma=0                  #Antes de realizar el conteo se toma un contador igual a cero
    for i in range(n):      #n filas del arreglo A
        for j in range(m):  #m columnas del arreglo A
            if A[i][j]==3:  #Para cada espacio se verifica si está identificado con el estado D
                suma=suma+1 #Si es verdadero, aumente en uno el contador de recuperados
    return int(suma)        #cantidad de individuos muertos en el arreglo A

"""**Ejemplo 1:** Considere la siguiente vecindad"""

#E1 = np.array([[0,-1,1],[2,1,0],[-1,2,-1]])
#E1

#L1=[]
#L1.append(sumaS(E1)); L1.append(sumaI(E1)); L1.append(sumaR(E1)); L1.append(sumaV(E1))
#L1

"""Observe que la célula central no se toma en cuenta, de esta manera $N_{22}(I)=1$.

Para poder comparar posteriormente los resultados de la simulación con los modelos descritos en EDO's debemos considerar una población normalizada, denote $n_{ij}^t(X)$ como la cantidad de individuos que poseen el estado $X$ en el estado del sistema en un tiempo $t$.
"""

def num_individuals(A): #Función contadora de individuos que interactuan en el sistema A 
    n = count_S(A)      #Cantidad de individuos que poseen el estado S
    m = count_I(A)      #Cantidad de individuos que poseen el estado I
    o = count_R(A)      #Cantidad de individuos que poseen el estado R
    d = count_D(A)      #Cantidad de individuos que poseen el estado D
    ci = n + m + o + d  #Total de individuos que interactuan en el sistema
    return ci           #Retorna ci

def count_s(A):                          #Función de población normalizada para el estado S          
    return count_S(A)/num_individuals(A) #Promedio de susceptibles con respecto a células que interactuan

def count_i(A):                          #Función de población normalizada para el estado I
    return count_I(A)/num_individuals(A) #Promedio de infectados con respecto a células que interactuan

def count_r(A):                          #Función de población normalizada para el estado R
    return count_R(A)/num_individuals(A) #Promedio de recuperados con respecto a células que interactuan

def count_d(A):                          #Función de población normalizada para el estado D
    return count_D(A)/num_individuals(A) #Promedio de muertos con respecto a células que interactuan

"""Una vez dicho esto considere los siguientes eventos:

1.   Si $\beta>\alpha$, es decir, si el individuo tiene un estado de susceptibilidad la probabilidad de adquirir la infección es mas alta que la probabilidad de mantenerse sano, mientras que si el individuo se encuentra infectado la probabilidad de mantenerse en ese estado sera mayor que la probabilidad de pasar al estado susceptible; debemos tener también en cuenta que el indicador $N_{ij}^t(I)$ sera de vital importancia debido a que a mayor valor de $N_{ij}^t(I)$ mayor sera la probabilidad de infectarse independientemente de el parámetro  $\beta$, teniendo esto en cuenta la regla para este evento sera:

    $$\textit{"Si }x_{i,j}^{t}=0\textit{, }N_{ij}^t(I)>N_{ij}^t(S)\textit{ y }\rho>\frac{\beta}{\alpha}\cdot \frac{N_{ij}^t(I)}{8}\cdot100\textit{ entonces }x_{ij}^{t+1}=1\textit{"}$$
    
    donde $\rho$ es un valor aleatorio entre 0 y 100, de igual manera se define la siguiente regla:
    $$\textit{"Si }x_{i,j}^{t}=1\textit{ y }\rho<\frac{\beta}{\alpha}\cdot \frac{N_{ij}^t(I)}{8}\cdot100\textit{, entonces }x_{ij}^{t+1}=1\textit{"}$$
2.   Si $\beta<\alpha$, es decir, si el individuo tiene un estado de infección la probabilidad de adquirir pasar al estado sano es mas alta que la probabilidad de mantenerse infectado, mientras que si el individuo se encuentra sano la probabilidad de mantenerse en ese estado sera mayor que la probabilidad de pasar al estado infectado, teniendo esto en cuenta la regla para este evento sera:
    $$\textit{"Si }x_{ij}^{t}=1\textit{, }N_{ij}^t(I)<N_{ij}^t(S)\textit{ y }\rho\leq\frac{\beta}{\alpha}\cdot \frac{N_{ij}^t(I)}{8}\cdot100\textit{ entonces }x_{ij}^{t+1}=0\textit{"}$$
    de igual manera se define la siguiente regla:
    $$\textit{"Si }x_{ij}^{t}=0\textit{ y }\rho\geq\frac{\beta}{\alpha}\cdot \frac{N_{ij}^t(I)}{8}\cdot100\textit{, entonces }x_{ij}^{t+1}=0\textit{"}$$


Observe que los estados 1. y 2. se pueden representar mediante la siguiente asignación

$$\Phi_{ij}^t(\alpha,\beta)=\left\{\begin{array}{cc}
0 & \textrm{si }\rho\leq\frac{\beta}{\alpha}\cdot \frac{N_{ij}^t(I)}{8}\cdot100\\
1 & \textrm{en otro caso}
\end{array}\right.$$

Claramente la asignación $\Phi_{ij}^t$ corresponde a una regla totalística, se decidió hacer uso de estas reglas sobre autómatas celulares debido a la complejidad encontrada en la variedad de vecindades que puede tener un agente perteneciente a cualquiera de los dos estados.

De manera forma definimos la función de transición entre los estados susceptible e infectado como:

**Definición:** Definimos la *regla base de interacción local* como

\begin{equation}
\Phi_{ij}^t(\alpha,\beta)=\left\{\begin{array}{cc}
0 & \textrm{si }r\leq\frac{\beta}{\alpha}\cdot \frac{N_{ij}^t(I)}{8}\cdot100\\
1 & \textrm{en otro caso}
\end{array}\right.
\end{equation}

donde $\alpha$ y $\beta$ representan la tasa de recuperación y la tasa de infección, respectivamente.

*Observación:* Como veremos más adelante, la cantidad de indiviuos que interactuan en la vecindad no necesariamente es 8, esto se deberá a que los individuos que posean el estado vacio se mantendrán en ese estado para todo tiempo $t$, de esta forma el comportamiento del individuo central no se verá afectado por los espacios vacios, por lo tanto una consideración importante en nuestra regla base de interacción local, será la cantidad de vecinos que interactuan con la célula central, de esta forma:

\begin{equation}
\Phi_{ij}^t(\alpha,\beta)=\left\{\begin{array}{cc}
0 & \textrm{si }r\leq\frac{\beta}{\alpha}\cdot \frac{N_{ij}^t(I)}{8-N_{ij}^t(V)}\cdot100\textrm{, si }N_{ij}^t(V)\neq8\\
1 & \textrm{en otro caso}
\end{array}\right.
\end{equation}

El caso $N_{ij}^t(V)=8$ no se considera, pues si llegase a ser este el caso, si el individuo adquiere el estado $S$ en algún tiempo $t$, entonces se mantendra con este estado en todo tiempo $t$.
"""

def base_rule(alpha,beta,V):                    #Regla base de interacción local      
    I = sumaI(V); S = sumaS(V); Va = sumaV(V)   #Se realiza un conteo de infectados, susceptibles y espacios vacios en la vecindad V            
    B = np.zeros((3,3))                         #Para evitar problemas de apuntadores se realiza la transformación sobre una copia de V
    r = random.randint(0,100)                   #El valor aleatorio rho
    for i in range(3):                          #Copia de las tres filas de la vecindad V
        for j in range(3):                      #Copia de las tres columnas de la vecindad V
            B[i][j] = V[i][j]                   #Copia de los indiviuos en la vecindad V
    if V[1][1] != -1:                                           #Se consideran unicamente los espacios no vacios ya que la tranformación de un espacio vacio es vacio
        if I > 0:                                               #Si no hay infectados en la vecindad, no hay propagacióón de la enfermedad en la vecindad
            if I <= S and r >= (I/(8 - Va))*(beta/alpha) * 100: #Condición para transición al estado S 
                B[1][1] = 0     
            else:                                               #Condición para transición al estado I
                B[1][1] = 1
        else:
            B[1][1] = V[1][1]
    else:                                       #Si la célula es vacia se mantiene vacia
        B[1][1] = -1
    return B[1][1]                              #Al ser una regla totalíística, se retorna el valor central

"""Observe que al aplicar la regla base de interacción local un individuo infectado puede tomar un estado de susceptibilidad, este tipo de comportamientos se evidencian en un modelo tipo SIS.

**Ejemplo 2:** Considere la vecindad del ejemplo 1, al aplicar la regla base de interacción local a la vecindad E1, tenemos
"""

#E1

#base_rule(0.45,0.5,E1)

"""Si $\textrm{base_rule}(0.45,0.5,E1) = 0.0$, el agente $x_{22}$ se curo de la enfermedad, si por otro lado $\textrm{base_rule}(0.45,0.5,E1) = 1.0$, el individuo se mantuvo infectado.

#### Modelo $SIS$ en AC

Como se vio en la sección "Modelo $SIS$ en EDO's", el modelo $SIS$ describe la interacción entre los estados $S$ e $I$, esto se puede interpretar como aplicar la regla base de evolución a cada agente presente en el estado del sistema.

**Definición:** Sea $\Phi^t:\mathbb{Z}\textrm{ x }\mathbb{Z}\to\mathbb{Z}\textrm{ x }\mathbb{Z}$ una aplicación definida por $\Phi^t(x_{ij}^t)=\phi_{ij}^t(x_{ij}^{t})=x_{ij}^{t+1}\in\sum$. Definimos $\Phi^t$ como la regla base de interacción global en el tiempo $t$.

*Observación:* Como se consideran arreglos bidimensionales finitos, al aplicar la regla base de interacción sobre los individuos que se encuentran en la frontera, no estaría bien definido, pues no existirían vecinos fuera del sistema. Una solución a este problema puede ser identificar los bordes superiores con los inferiores y los bordes laterales, generando así, un toro; como uno de los objetivos de la investigación es analizar la evolución de una enfermedad a partir de la dispersión inicial de los individuos infectados, esta no será la medida implementada. La solución que proponemos frente a esta dificultad se describe mediante el siguiente algoritmo:

**Algoritmo de evolución para las fronteras del sistema**

**Paso 1:** Defina el arreglo regular $U\subset\mathbb{Z}\textrm{ x }\mathbb{Z}$ de dimensión $n\textrm{ x }m$.

**Paso 2:** Defina $U'$ como $U$ aumentado en dos filas y dos columnas de ceros generando un borde nulo sobre $U$.

**Paso 3:** Aplique $\Phi^t$ sobre $U$ y mantenga constante las filas nulas descritas en el paso 2.

**Paso 4:** Defina $\Phi^t(U)$ como el conjunto descrito en el paso 3 eliminando los bordes nulos generados en el paso 2.
"""

def evolution_sis(alpha,beta,U):  #Regla base de evolucion en U de parametros alpha y beta
    n,m=U.shape                   #dim(U)=nm
    B=np.zeros((n+2,m+2))         #B será un arreglo nulo sobre el cual se sobreescribiran los datos de U
    C=np.zeros((n,m))             #C será el arreglo que guardará los datos luego de aplicar la regla base de evolución 
    I=count_I(U)                  #Se aplicará la regla siempre y cuando existan individuos infectados
    for i in range(n):                              
        for j in range(m):
            B[i+1][j+1]=U[i][j]   #Se sobreescriben los datos de U sobre B
    for i in range(n):
        for j in range(m):
            if I > 0:                                                      #Si hay individuos infectados en el sistema
                C[i][j]=base_rule(alpha,beta,array_generator(B,i+1,j+1))   #Aplique la regla base de evolución local a U y guarde los valores en C 
            else:                                                          #Si no hay individuos infectados
                C[i][j] = U[i][j]                                          #La regla base de evolución actua como la función identica sobre el sistema
    return C                      #Retorne la evolución del sistema

"""**Definición:** Defina el conjunto $E_{SIS}^{t_f}(A)$ como el conjunto de evoluciones consecutivas sobre el arreglo $A$ hasta un tiempo $t_f$."""

def evolution_SIS(alpha,beta,tf,A):         #Definición del conjunto de evoluciones 
    L = [A]                                 #El primer elemento del conjunto es la configuracióón inicial
    i = 0                                   #Se define el contador de composiciones
    while i <= tf:                                 #Se realizarán composiciones hasta el tiempo tf 
        i = i + 1                                  #El contador crece en una unidad
        L.append(evolution_sis(alpha,beta,L[i-1])) #Se añade la composición i del arreglo en la posición i-1 
    return L                                       #Se retorna el conjunto de composiciones que describe la evolucióón de A

def SIS_model(alpha,beta,tf,A):                   #Modelo SIS
    S = []; I = []                                #S e I guardan la cantidad de individuos pertenecientes a los estados S e I por cada iteración 
    CI = np.zeros((tf,2)); CS = np.zeros((tf,2))  #CS y CI nos permitiran graficar los datos de S e I
    B = evolution_SIS(alpha,beta,tf,A)            #Calculamos la evolución inicial del sistema A hasta el tiempo tf
    for j in range(tf):                           #Para cada iteración defina
        M = B[j]                                  #M será la evolución en el instante t=i
        S.append(count_s(M))                      #Añadimos el promedio de susceptibles en M a S 
        I.append(count_i(M))                      #Añadimos el promedio de infectados en M a I                           
    for i in range(tf):                           #Para cada instante i hasta tf defina
        CS[i][0] = i; CS[i][1] = S[i]             #CS[i]=(i,S[i]) -> (tiempo i, cantidad de susceptibles en el tiempo i)
        CI[i][0] = i; CI[i][1] = I[i]             #CI[i]=(i,I[i]) -> (tiempo i, cantidad de infectados en el tiempo i)
    return [CS,CI,S,I,B]                          #Lista con las parejas ordenadas CS, CI, cantidad de individuos susceptibles, infectados y las evoluciones del sistema

"""**Ejemplo 3:** Considere un arreglo de dimensión $5\cdot10$, donde el $10\%$ de la población inicial esta recuperado y el $90\%$ es susceptible a la enfermedad, tomando como tasas de infección $\beta=0.6$ y de recuperación $\alpha=0.3$. Describa el comportamiento del sistema en periodo de $15$ tics, es decir, $15$ iteraciones.

**Solución:** Primero debemos definir el sitema inicial, considere un arreglo nulo de tamaño $5\cdot10$

Para poder aplicar la condición inicial debemos introducir una función que describa la configuración inicial del sistema E3. Para esto debemos realizar los siguientes pasos:

**Definición de la condición inicial - Modelo $SIS$**

**Paso 1:** Defina el porcentaje de individuos infectados en el sistema. En el caso del *ejemplo E3* $I_0=10\%$, es decir $1$ de cada $10$ individuos está infectado.

**Paso 2:** Defina un arreglo nulo de tamaño $n\cdot m$, la condición inicial se aplica sobre un espacio completamente susceptible a la enfermedad.

**Paso 3:** El $I_0\%$ de los individuos del sistema estrán enfermos, esto se puede ver como que $\lceil C^t(S)*I0\%\rceil$ estarán enfermos en la configuración inicial.

**Paso 4:** Modifique las posiciones del arreglo definido en el paso 2 por unos, es decir, los individuos que adquieren el estado de infección.

**Paso 5:** Retorne la configuración inicial del sistema.
"""

def num_I(a,b):               #Porcentaje de infectados en el espacio (a de cada b están infectados)
    A=np.zeros((1,b))         #Generamos una b-tupla, la vemos como un arreglo para facilitar la manipulación 
    L=[]                      #L sera la lista cuyos elelementos son a de b infectados
    for j in range(a):          #a individuos recibirán la cualidad de infectados 
        i=random.randint(1,b-1) #La posición de los individuos infectados será aleatoria en el arreglo A
        A[0][i]=1               #El individuo en la posición aleatoria 0,i adquiere el estado de infección 
    for m in range(1,b):        #Se añadirán los elementos del arreglo A en la lista L
        L.append(int(A[0][m]))  
    return L                  #Retorne la lista porcentaje de indiviuos infectados

def initial_condition(I0,A):   #Condición inicial aplicada al sistema A
    L=vector_S(A)              #Defina L como el vector de posiciones del estado S en el sistema A
    n,m=A.shape                #dim(A)=nm
    k=math.ceil(len(L)*I0)     #El I0% de los individuos susceptibles adquieren la enfermedad, se toma la función techo para redondear a un entero esta cantidad
    R=num_I(k,len(L)+1)        #R es la lista de posiciones de los idividuos que se infectaron y de los que se mantuvieron sanos al aplicar la condicion inicial
    C=np.zeros((n,m))          #Se define C para evitar problemas de apuntadores
    for i in range(n):            #Para i en las n filas de A 
        for j in range(m):        #Para j en las m columnas de A
            C[i][j]=A[i][j]       #C será una copia de A, esto permite que la información de A no se modifique
    for i in range(len(R)):       #Para i en un rango de 0 a la longitud de la lista R
        C[L[i][0]][L[i][1]]=R[i]  #Los vectores en las posiciones descritas en la lista R adquieren el estado de infección
    return C                   #Se retorna el arreglo con la condición inicial

E3 = np.zeros((5,10))
E3

E3 = initial_condition(0.1, E3)
E3

"""Para poder visualizar el comportamiento de la enfermedad debemos implementar funciones que grafiquen los valores $n^t(S)$ y $n^t(I)$, se toman los datos normalizados para poder comparar las trayectorias entre el modelo en EDO's y el modelo en AC."""

def graph_sis_S(alpha,beta,tf,A):          #Grafica que describe la evolución de la población susceptible en el modelo SIS
    SIS=SIS_model(alpha,beta,tf,A)         #Se aplica el modelo al sistema A, con tasas de recuperación e infección hasta un tiempo tf
    one_state_graph(SIS[0],"Susceptibles") #Graficamos los datos mediante un spline cubico de la lista S generada por la función sis

#graph_sis_S(0.3, 0.6, 15, E3)

def graph_sis_I(alpha,beta,tf,A):          #Grafica que describe la evolución de la población infectados en el modelo SIS
    SIS=SIS_model(alpha,beta,tf,A)         #Se aplica el modelo al sistema A, con tasas de recuperación e infección hasta un tiempo tf
    one_state_graph(SIS[1], "Infectados")  #Graficamos los datos mediante un spline cubico de la lista I generada por la función sis

#graph_sis_I(0.3, 0.6, 15, E3)

def graph_sis(alpha,beta,tf,A):         #Grafica del modelo SIS
    SIS=SIS_model(alpha,beta,tf,A)      #Se aplica el modelo al sistema A, con tasas de recuperación e infección hasta un tiempo tf
    two_states_graph(SIS[0],SIS[1],"Susceptibles", "Infectados", "Modelo SIS")  #Graficamos los datos mediante un spline cubico de las listas S e I generadas por la función sis

graph_sis(0.3, 0.6, 15, E3)

"""### Reglas de interacción entre los estados

Observe que el modelo $SIS$ describe adecuadamente la evolución de una enfermedad en la cuál los individuos pueden adquirir un estado de susceptibilidad o infección en el tiempo dependiendo de las cualidades de la enfermedad, esto implica que un individuo que se recupera de la enfermedad puede volver a contraerla, este es al caso de la gripa común o influenza.

Sin embargo, no todas las enfermedades poseen esta característica, considere por ejemplo la varicela, los individuos que adquieren esta enfermedad pueden curarse, generando así inmunidad. De esta forma, los individuos que se recuperan no podrar adquirir un estado de susceptibilidad a lo largo del tiempo, razón por la cual se deberán introducir reglas de interacción entre los estados de $\sum$ que describan las interacciones entre $S$ e $I$ y las interacciones entre $I$ y $R$.

#### Reglas de interacción - Estado S

Sin tomar en cuenta la vacunación, los individuos que sean susceptibles a la enfermedad no podrán recuperarse, es decir no existe una interacción entre el estado $S$ y el estado $R$; por otro lado los individuos que están infectados a un tiempo $t$ no podrán adquirir la cualidad de susceptibilidad para un tiempo mayor a $t$, esto debido a que "ganaron" inmunidad frente a la enfermedad, dicho esto definimos la regla de interacción para el estado $S$ como:

**Definición:** ***(Regla de interaccion del estado $S$)*** Los individuos que posean el estado $S$ únicamente podrán adquirir un estado de infección mediante la regla base de interacción local, esta regla se conocerá como regla de interacción para el estado $S$.

***Observación:*** Podemos entender la regla de interacción del estado $S$ como una restricción de la regla base de propagación local, esto debido a que los individuos con estado $I$ no podrán adquirir el estado $S$ en todo tiempo $t$. De esta forma, otra manera de enunciar la regla de interacción del estado $S$ podría ser: Los individuos con estado $S$ seguirán un comportamiento descrito por la regla base de interacción, para los estados $I$ y $R$ esta regla de interaccióón actuará como la identidad.
"""

def interaction_SI(alpha,beta,A):     #Regla de interacción del estado S
    n,m=A.shape                       #dim(A)=nm
    B=np.zeros((n+2,m+2))             #Se aplica la condición para las células en la frontera
    C=np.zeros((n,m))                 #Se define la matriz C para evitar problemas de apuntadores
    for i in range(n):
        for j in range(m):
            B[i+1][j+1]=A[i][j]           
    for i in range(n):
        for j in range(m): 
            if A[i][j]==0:                                                #Si el estado de la célula es susceptible aplique la regla base de interaccion local
                C[i][j]=base_rule(alpha,beta,array_generator(B,i+1,j+1))
            elif A[i][j]==2:                                              #Para el estado R funciona como la identidad
                C[i][j]=2
            elif A[i][j]==-1:                                             #La regla no se aplica en espacios vacios
                C[i][j]=-1
            elif A[i,j]==3: #opcional
                C[i,j]=3
            else:                                                         #La regla actua como la identica en el estado I
                C[i][j]=1
    return C                                                              #Retorna la evolución del sistema A bajo la regla de S

"""Por ejemplo, consideremos el vecindario en el lado izquierdo de la siguiente figura, tenga en cuenta que las células $𝑥_{12}$ y $𝑥_{23}$ tienen dos vecinos infectados, entonces es más probable que estas células se enfermen que las células $𝑥_{21}$, $𝑥_{32}$ y $𝑥_{31}$, cuando aplicamos la regla de transición del estado $S$ vemos que las células $𝑥_{12}$, $𝑥_{23}$ y $𝑥_{32}$ se infectaron y que la célula $𝑥_{22}$ permaneció sana a pesar de tener $3$ vecinos infectados.

![texto alternativo](https://docs.google.com/drawings/d/e/2PACX-1vRr1u1168qbhGf0HboUHSn5_Nqr4iK6enBR1XcdZB7zmxlyNEKDp1edUl_7Yul_ojuk_WFXPMif98cH/pub?w=977&h=300)

#### Reglas de interacción - Estado I

Si consideramos $\alpha$ como la probabilidad de recuperación individual, esto es equivalente a pensar que $\alpha\%$ de las personas infectadas se recuperarán. Por lo tanto, el número de individuos que serán recuperados será

\begin{equation}
    P_{I\to R}(C^t(I),\alpha)=\lceil N^t(I)\cdot\alpha\rceil
\end{equation}

Dicho esto, definiremos la regla de interacción del estado $I$ como:

**Definición:** Defina la transformación 

\begin{align*}
    T_\alpha:(\mathbb{Z}\textrm{ x }\mathbb{Z})/{\sum}&\longrightarrow (\mathbb{Z}\textrm{ x }\mathbb{Z})/{\sum}\\
    C^t(X)&\longmapsto T_\alpha(C^t(X))=C^{t+1}(X)
\end{align*} 

Donde la asignación $T_\alpha(C^t(I))$ envia $\alpha\%$ de los individuos infectados al estado $R$, para los estados $S$, $R$ y $V$ la aplicación $T_\alpha$ funciona como la identidad. Conoceremos a la función $T_\alpha$ como la regla de interacción del estado $I$
"""

def num_R(a,b):               #Porcentaje de recuperados en el espacio (a de cada b están curados)
    A=np.ones((1,b))          #Generamos una b-tupla, la vemos como un arreglo para facilitar la manipulación 
    L=[]                      #L sera la lista cuyos elelementos son a de b recuperados
    for j in range(a):          #a individuos recibirán la cualidad de recuperados
        i=random.randint(1,b-1) #La posición de los individuos recuperados será aleatoria en el arreglo A
        A[0][i]=2               #El individuo en la posición aleatoria 0,i adquiere el estado de recuperado
    for m in range(1,b):        #Se añadirán los elementos del arreglo A en la lista L
        L.append(int(A[0][m]))  
    return L                  #Retorne la lista porcentaje de indiviuos recuperados

def interaction_IR(alpha,A):      #Regla de interacción del estado I
    L=vector_I(A)                 #Generamos el conjunto de posiciones de infectados del sistema A
    n,m=A.shape                   #dim(A)=nm
    k=math.ceil(len(L)*alpha)     #alpha% de los infectados se curará
    R=num_R(k,len(L)+1)           #Generamos la lista en la cual de manera explicita tenemos alpha recuperados de una poblacióón infectada
    C=np.zeros((n,m))             #Se creará una copia de A para evitar problemas de apuntadores
    for i in range(n):
        for j in range(m):
            C[i][j]=A[i][j]
    for i in range(len(R)):       #Los individuos que se recuperarón se envian a la posición que tenian en el estado I  
        C[L[i][0]][L[i][1]]=R[i]
    return C                      #Retorna la evolución del sistema A bajo la regla de I

"""**Definición** Definimos la regla que describe el comportamiento del modelo $SIR$ como la "composición" de la regla de interacción del estado $S$ con la regla de interacción del estado $I$ 

**Definición:** Defina el conjunto $E_{SIR}^{t_f}(A)$ como el conjunto de evoluciones consecutivas sobre el arreglo $A$ hasta un tiempo $t_f$.
"""

def evolution_sir(alpha,beta,A):    #Regla de comportamiento SIR
    B=interaction_IR(alpha,A)      #Primero se evalua cuales individuos se curarán el el siguiente tic
    C=interaction_SI(alpha,beta,B)  #Los que no se curaróón siguen infectando la población susceptible
    return C                        #Sistema al aplicar la regla de comportamiento SIR

def evolution_SIR(alpha,beta,tf,A):         #Lista de evoluciones al aplicar SIR hasta un tiempo tf
    L=[A]                                   #El primer elemento de la lista es la configuración inicial
    i=0                                     #Aplique SIR hasta el tiempo tf
    while i<=tf:
        i=i+1
        L.append(evolution_sir(alpha,beta,L[i-1]))   #Se aplica SIR al arreglo en la posición anterior del contador
    return L                                         #Lista de evoluciones en un sistema bajo la aplicación SIR

def SIR_model(alpha,beta,tf,A):       #Modelo SIR
    S=[]; I=[]; R=[]                  #Listas que guardarán la cantidad de individuos por estado normalizada
    CI=np.zeros((tf,2))               #Arreglo que permitirá graficar la población infectada
    CS=np.zeros((tf,2))               #Arreglo que permitirá graficar la población susceptible
    CR=np.zeros((tf,2))               #Arreglo que permitirá graficar la población recuperada
    B=evolution_SIR(alpha,beta,tf,A)  #Lista de evoluciones del sistema A hasta el tiemp tf
    for j in range(tf):               #Para cada elemento en la lista 
        M=B[j]                        #M es la evolución en el tiempo j
        S.append(count_s(M))          #Población susceptible normalizada 
        I.append(count_i(M))          #Población infectada normalizada
        R.append(count_r(M))          #Población recuperada normalizada 
    for i in range(tf):               #Se generan las listas de coordenadas que permitirán graficar la evolución
        CS[i][0]=i; CS[i][1]=S[i]     #Coordenadas de cantidad de susceptibles
        CI[i][0]=i; CI[i][1]=I[i]     #Coordenadas de cantidad de infectados
        CR[i][0]=i; CR[i][1]=R[i]     #Coordenadas de cantidad de recuperados
    return [CS,CR,CI,S,I,R,B]         #Lista con las coordenadas de los tres estados, cantidades normalizadas y las evoluciones

"""**Ejemplo 4:** Aplique la regla de interacción del estado I al arreglo generado en el ejemplo 3 y describa el comportamiento del sistema en periodo de $30$ tics, es decir, $30$ iteraciones."""

E3

#interaction_IR(0.2,E3)

"""Para poder visualizar el comportamiento de la enfermedad debemos implementar funciones que grafiquen los valores $n^t(S)$, $n^t(I)$ y $n^t(R)$, se toman los datos normalizados para poder comparar las trayectorias entre el modelo en EDO's y el modelo en AC."""

def graph_sir_S(alpha,beta,tf,A):            #Gráfica de la población susceptible
    SIR=SIR_model(alpha,beta,tf,A)           #Se aplica el modelo bajo las condiciones de la función
    one_state_graph(SIR[0], "Susceptibles")  #Gráfica de la población susceptible

#graph_sir_S(0.3,0.6,30,E3)

def graph_sir_I(alpha,beta,tf,A):          #Gráfica de la población infectada
    SIR=SIR_model(alpha,beta,tf,A)         #Se aplica el modelo bajo las condiciones de la función      
    one_state_graph(SIR[2], "Infectados")  #Gráfica de la población infectada

#graph_sir_I(0.3,0.6,30,E3)

def graph_sir_R(alpha,beta,tf,A):          #Gráfica de la población recuperada      
    SIR=SIR_model(alpha,beta,tf,A)         #Se aplica el modelo bajo las condiciones de la función 
    one_state_graph(SIR[1], "Recuperados") #Gráfica de la población recuperada

#graph_sir_R(0.3,0.6,30,E3)

def graph_sir(alpha,beta,tf,A):      #Gráfica del modelo SIR
    SIR=SIR_model(alpha,beta,tf,A)   #Se aplica el modelo bajo las condiciones de la función 
    three_states_graph(SIR[0],SIR[1],SIR[2],"Susceptibles","recuperados","infectados","Modelo SIR")

#graph_sir(0.3,0.6,30,E3)

"""Debido a que estamos trabajando con entornos espaciales descritos por autómatas celulares, podemos hacernos la pregunta ¿Es posible que la distribución en el espacio de cada estado afecte en alguna característica la evolución del modelo?, para responder a esta pregunta incluiremos una función que permitiá visualizar de una manera apropiada a las evoluciones del sistema de estudio."""

def color(A):                 #Transformación que permite visualizar el sistema en escala nipy_spectral
    n,m=A.shape               #dim(A)=nm
    C=np.zeros((n,m))         #Se realizará una copia de A para evitar problemas de apuntadores
    for i in range(n):          
        for j in range(m):
            C[i][j]=A[i][j]
    for i in range(n):
        for j in range(m):
            if C[i][j]==0:    #A los individuos susceptibles se les asigna el color amarillo
                C[i][j]=190   
            if C[i][j]==1:    #A los individuos infectados se les asigna el color rojo
                C[i][j]=240
            if C[i][j]==2:    #A los individuos recuperados se les asigna el color verde
                C[i][j]=115
            if C[i][j]==-1:   #A los espacios vacios se les asigna el color negro
                C[i][j]=0
            if C[i][j]==3:
                C[i][j]=256
    D=np.zeros((n+2,m+2)) 
    for i in range(n):                              
        for j in range(m):
            D[i+1][j+1]=C[i][j]
    D[0][0]=0; D[n+1][m+1]=256  #Polos de color para poder ajustar la escala de manera adecuada
    return D

"""**Ejemplo 5:** Podemos visualizar ahora el comportamiento de la enfermedad desde una perspectiva mas ilustrativa, analicemos por ejemplo el ejemplo 3."""

#plt.imshow(color(E3),cmap="nipy_spectral", interpolation='nearest')

#plt.imshow(E3,cmap="gray", interpolation='nearest')

"""A partir de la función del color podemos realizar otro tipo de simulaciones, un poco más ilustrativas en cuanto al comportamiento de los autómatas en el tiempo. Se decidio realizar un video para visualizar la evolución espacial del sistema, para esto considere el siguiente ejemplo.

**Ejemplo 6:** La enfermedad A posee tasas de infección y de recuperación de $\beta=0.5$ y $\alpha=0.2$ respectivamente, considere una población infectada inicial del 10%. Analice el comportamiento de la enfermedad en un periodo de 30 tics en un sistema de dimensión $10\cdot10$.
"""

#E6=np.zeros((10,10))
#E6=initial_condition(0.1,E6)
#plt.imshow(color(E6),cmap="nipy_spectral", interpolation='nearest')

#SISE6=SIS_model(0.2,0.5,30,E6)[4]     #Evolución modelo SIS
#for i in range(30):
#  plt.imshow(color(SISE6[i]),cmap="nipy_spectral", interpolation='nearest')
#  plt.savefig('SISE6'+str(i)+'.jpg')

#img_SISE6 = []
#for i in range(30):
#    img = cv2.imread('SISE6'+str(i)+'.jpg')
#    height, width, layers = img.shape
#    size = (width,height)
#    img_SISE6.append(img)

#out = cv2.VideoWriter('SISE6.avi',cv2.VideoWriter_fourcc(*'DIVX'), 15, size)
 
#for i in range(len(img_SISE6)):
#    out.write(img_SISE6[i])
#out.release()

#SIRE6=SIR_model(0.2,0.5,30,E6)[6]     #Evolución modelo SIR
#for i in range(30):
#  plt.imshow(color(SIRE6[i]),cmap="nipy_spectral", interpolation='nearest')
#  plt.savefig('SIRE6'+str(i)+'.jpg')

#img_SIRE6 = []
#for i in range(30):
#    img = cv2.imread('SIRE6'+str(i)+'.jpg')
#    height, width, layers = img.shape
#    size = (width,height)
#    img_SIRE6.append(img)

#out = cv2.VideoWriter('SIRE6.avi',cv2.VideoWriter_fourcc(*'DIVX'), 15, size)
 
#for i in range(len(img_SIRE6)):
#    out.write(img_SIRE6[i])
#out.release()

"""Para visualizar la evolución de la enfermedad A consulte los archivos SISE6.avi y SIRE6.avi los cuales describen la evolución espacial para los dos modelos epidemiológicos descritos anteriormente.

Al observar los videos del ejemplo anterior podemos observar que en las zonas donde hayan mas individuos infectados, la enfermedad se propaga más rapido. Esto nos permite hacernos la pregunta ¿Que tanto afecta la distrbución espacial de los individuos infectados en la evolución del sistema?.

### La dispersión como un factor clave en la velocidad de propagación

En esta sección analizaremos la velocidad con la cual se propaga una enfermedad, dependiendo de la ubicación inicial de la población infectada, para esto decidimos dividir el espacio en nueve bloques, los estarán directamente identificados con los puntos cardinales. 

Posteriormente analizaremos ejemplos particulares que nos permitirán realizar una mejor interpretación de la evolución del sistema bajo una condición inicial de distribución de la población enferma.

Una vez implementadas las funciones de distribución espacial podemos realizar un análisis detallado sobre estas condiciones iniciales, para esto estudiaremos la evolución de una enfermedad para cada condición inicial aplicadas en los modelos previamente mencionados.

A continuación implemetaremos una función que nos permitirá visualizar cuales fuerón los puntos donde se desarrollo en mayor parte del tiempo la enfermedad.
"""

def heatmap_sis(alpha,beta,tf,A):                          #Mapa de calor de la enfermedad hasta el tiempo tf
    a,b=A.shape
    B=SIS_model(alpha,beta,tf,A)[4]
    C=[]
    for i in range(len(B)):
        D=np.zeros((a,b)); F=np.zeros((a,b))
        for j in range(a):
            for k in range(b):
                if B[i][j][k]==1:
                    D[j][k]=1
        C.append(D)
    suma1=1/tf*np.sum(C,axis=0)
    sns.heatmap(suma1, center=0, cmap='viridis',  fmt='.3f')

def heatmap_sir_I(alpha,beta,tf,A):
    a,b=A.shape
    B=SIR_model(alpha,beta,tf,A)[6]
    C=[]
    for i in range(len(B)):
        D=np.zeros((a,b)); F=np.zeros((a,b))
        for j in range(a):
            for k in range(b):
                if B[i][j][k]==1:
                    D[j][k]=1
        C.append(D)
    suma1=1/tf*np.sum(C,axis=0)
    sns.heatmap(suma1, center=0, cmap='viridis',  fmt='.3f')

def heatmap_sir_R(alpha,beta,tf,A):
    a,b=A.shape
    B=SIR_model(alpha,beta,tf,A)[6]
    C=[]
    for i in range(len(B)):
        D=np.zeros((a,b)); F=np.zeros((a,b))
        for j in range(a):
            for k in range(b):
                if B[i][j][k]==2:
                    D[j][k]=1
        C.append(D)
    suma1=1/tf*np.sum(C,axis=0)
    sns.heatmap(suma1, center=0, cmap='viridis',  fmt='.3f')

"""**Enfermedad A:** Posee tasas de infección y recuperación de $\beta=0.5$ y $\alpha=0.2$, el $10\%$ de la enfermedad se encuentra enferma en el tiempo $t=0$. Describa el comportamiento de la enfermedad en $100$ tics."""

def northwest(n,m,I0):               #Bloque noroeste
    D=np.zeros((n,m))                #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*0.005,D)  #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque noroeste 
    a=int(n/3); b=int(m/3)           #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(0.995-I0,A) 
    for i in range(a):
        for j in range(b):
            D[i][j]=D1[i][j]         #Se reemplazan los valores del bloque noroeste por el bloque de infectados
    return D

#plt.imshow(color(northwest(30,30,0.1)),cmap="nipy_spectral", interpolation='nearest')

#graph_sis(0.2,0.5,100,northwest(30,30,0.1)) #Modelo  SIS

#graph_sir(0.2,0.5,100,northwest(30,30,0.1)) #Modelo  SIR

#heatmap_sis(0.2,0.5,30,northwest(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_I(0.2,0.5,30,northwest(30,30,0.1))

#heatmap_sir_R(0.2,0.5,30,northwest(30,30,0.1))

def north(n,m,I0):                    #Bloque norte
    D=np.zeros((n,m))                 #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)    #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque norte
    a=int(n/3); b=int(m/3)            #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                 #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(0.995-I0,A)
    for i in range(a):
        for j in range(b,2*b):
            D[i][j]=D1[i][j-b]        #Se reemplazan los valores del bloque norte por el bloque de infectados
    return D

#plt.imshow(color(north(27,27,0.1)),cmap="nipy_spectral", interpolation='nearest')

#graph_sis(0.2,0.5,100,north(30,30,0.1)) #Modelo  SIS

#graph_sir(0.2,0.5,100,north(30,30,0.1)) #Modelo  SIR

#heatmap_sis(0.2,0.5,30,north(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_I(0.2,0.5,30,north(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_R(0.2,0.5,30,north(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

def northeast(n,m,I0):                #Bloque noreste
    D=np.zeros((n,m))                 #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)    #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque noreste
    a=int(n/3); b=int(m/3)            #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                 #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(a):
        for j in range(2*b,3*b):
            D[i][j]=D1[i][j-2*b]      #Se reemplazan los valores del bloque noreste por el bloque de infectados
    return D

#plt.imshow(color(northeast(27,27,0.1)),cmap="nipy_spectral", interpolation='nearest')

#graf_sis(0.2,0.5,100,northeast(30,30,0.1)) #Modelo  SIS

#graf_sir(0.2,0.5,100,northeast(30,30,0.1)) #Modelo  SIR

#heatmap_sis(0.2,0.5,30,northeast(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_I(0.2,0.5,30,northeast(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_R(0.2,0.5,30,northeast(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

def west(n,m,I0):                    #Bloque oeste
    D=np.zeros((n,m))                #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)   #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque oeste
    a=int(n/3); b=int(m/3)           #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(a,a*2):
        for j in range(b):
            D[i][j]=D1[i-a][j]        #Se reemplazan los valores del bloque oeste por el bloque de infectados
    return D

#plt.imshow(color(west(27,27,0.1)),cmap="nipy_spectral", interpolation='nearest')

#graf_sis(0.2,0.5,100,west(30,30,0.1)) #Modelo  SIS

#graf_sir(0.2,0.5,100,west(30,30,0.1)) #Modelo  SIR

#heatmap_sis(0.2,0.5,30,west(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_I(0.2,0.5,30,west(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_R(0.2,0.5,30,west(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

def center(n,m,I0):                  #Bloque central
    D=np.zeros((n,m))                #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)   #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque central
    a=int(n/3); b=int(m/3)           #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(a,a*2):
        for j in range(b,2*b):
            D[i][j]=D1[i-a][j-b]      #Se reemplazan los valores del bloque central por el bloque de infectados
    return D

#plt.imshow(color(center(30,30,0.1)),cmap="nipy_spectral", interpolation='nearest')

#graf_sis(0.2,0.5,100,center(30,30,0.1)) #Modelo  SIS

#graf_sir(0.2,0.5,100,center(30,30,0.1)) #Modelo  SIR

#heatmap_sis(0.2,0.5,30,center(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_I(0.2,0.5,30,center(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_R(0.2,0.5,30,center(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

def east(n,m,I0):                    #Bloque este
    D=np.zeros((n,m))                #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)   #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque este
    a=int(n/3); b=int(m/3)           #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(a,a*2):
        for j in range(2*b,3*b):
            D[i][j]=D1[i-a][j-2*b]   #Se reemplazan los valores del bloque este por el bloque de infectados
    return D

#plt.imshow(color(east(30,30,0.1)),cmap="nipy_spectral", interpolation='nearest')

#graf_sis(0.2,0.5,100,east(30,30,0.1)) #Modelo  SIS

#graf_sir(0.2,0.5,100,east(30,30,0.1)) #Modelo  SIR

#heatmap_sis(0.2,0.5,30,east(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_I(0.2,0.5,30,east(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_R(0.2,0.5,30,east(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

def southwest(n,m,I0):                #Bloque suroeste
    D=np.zeros((n,m))                 #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)    #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque suroeste
    a=int(n/3); b=int(m/3)            #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                 #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(2*a,3*a):
        for j in range(b):
            D[i][j]=D1[i-2*a][j]      #Se reemplazan los valores del bloque suroeste por el bloque de infectados
    return D

#plt.imshow(color(southwest(27,27,0.1)),cmap="nipy_spectral", interpolation='nearest')

#graf_sis(0.2,0.5,100,southwest(30,30,0.1)) #Modelo  SIS

#graf_sir(0.2,0.5,100,southwest(30,30,0.1)) #Modelo  SIR

#heatmap_sis(0.2,0.5,30,southwest(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_I(0.2,0.5,30,southwest(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_R(0.2,0.5,30,southwest(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

def south(n,m,I0):                  #Bloque sur
    D=np.zeros((n,m))               #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)  #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque sur
    a=int(n/3); b=int(m/3)          #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))               #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(2*a,3*a):
        for j in range(b,2*b):
            D[i][j]=D1[i-2*a][j-b]    #Se reemplazan los valores del bloque sur por el bloque de infectados
    return D

#plt.imshow(color(south(30,30,0.1)),cmap="nipy_spectral", interpolation='nearest')

#graf_sis(0.2,0.5,100,south(30,30,0.1)) #Modelo  SIS

#graf_sir(0.2,0.5,100,south(30,30,0.1)) #Modelo  SIR

#heatmap_sis(0.2,0.5,30,south(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_I(0.2,0.5,30,south(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_R(0.2,0.5,30,south(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

def southeast(n,m,I0):                #Bloque sureste
    D=np.zeros((n,m))                 #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0*.005,D)    #Un porcentaje muy pequeño de los individuos infectados no se encontrará en el bloque sureste
    a=int(n/3); b=int(m/3)            #Se divide la zona rectángular en 9 bloques
    A=np.zeros((a,b))                 #Bloque sobre el cual estarán ubicados la mayoria de los enfermos
    D1=initial_condition(.995-I0,A)
    for i in range(2*a,3*a):
        for j in range(2*b,3*b):
            D[i][j]=D1[i-2*a][j-2*b]  #Se reemplazan los valores del bloque sureste por el bloque de infectados
    return D

#plt.imshow(color(southeast(27,27,0.1)),cmap="nipy_spectral", interpolation='nearest')

#graf_sis(0.2,0.5,100,southeast(30,30,0.1)) #Modelo  SIS

#graf_sir(0.2,0.5,100,southeast(30,30,0.1)) #Modelo  SIR

#heatmap_sis(0.2,0.5,30,southeast(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_I(0.2,0.5,30,southeast(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_R(0.2,0.5,30,southeast(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

def aleatorio(n,m,I0):        #Distribución aleatoria en el espacio
    D=np.zeros((n,m))         #Creamos el arreglo rectángular sobre el cual se realizará el analisis
    D=initial_condition(I0,D) #Se aplica la condición inicial
    return D

#plt.imshow(color(aleatorio(30,30,0.1)),cmap="nipy_spectral", interpolation='nearest')

#graf_sis(0.2,0.5,100,aleatorio(30,30,0.1)) #Modelo  SIS

#graf_sir(0.2,0.5,100,aleatorio(30,30,0.1)) #Modelo  SIR

#heatmap_sis(0.2,0.5,30,aleatorio(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_I(0.2,0.5,30,aleatorio(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

#heatmap_sir_R(0.2,0.5,30,aleatorio(30,30,0.1)) #Mapa de calor de la enfermedad en 30 tics

SIS1=SIS_model(0.2,0.5,50,northwest(30,30,0.1))
SIS2=SIS_model(0.2,0.5,50,north(30,30,0.1))
SIS3=SIS_model(0.2,0.5,50,northeast(30,30,0.1))
SIS4=SIS_model(0.2,0.5,50,west(30,30,0.1))
SIS5=SIS_model(0.2,0.5,50,center(30,30,0.1))
SIS6=SIS_model(0.2,0.5,50,east(30,30,0.1))
SIS7=SIS_model(0.2,0.5,50,southwest(30,30,0.1))
SIS8=SIS_model(0.2,0.5,50,south(30,30,0.1))
SIS9=SIS_model(0.2,0.5,50,southeast(30,30,0.1))
SIS10=SIS_model(0.2,0.5,50,aleatorio(30,30,0.1))

SIR1=SIR_model(0.2,0.5,50,northwest(30,30,0.1))
SIR2=SIR_model(0.2,0.5,50,north(30,30,0.1))
SIR3=SIR_model(0.2,0.5,50,northeast(30,30,0.1))
SIR4=SIR_model(0.2,0.5,50,west(30,30,0.1))
SIR5=SIR_model(0.2,0.5,50,center(30,30,0.1))
SIR6=SIR_model(0.2,0.5,50,east(30,30,0.1))
SIR7=SIR_model(0.2,0.5,50,southwest(30,30,0.1))
SIR8=SIR_model(0.2,0.5,50,south(30,30,0.1))
SIR9=SIR_model(0.2,0.5,50,southeast(30,30,0.1))
SIR10=SIR_model(0.2,0.5,50,aleatorio(30,30,0.1))

"""***Población susceptible - Modelo SIS***"""

distribution_graph(SIS1[0],SIS2[0],SIS3[0],SIS4[0],SIS5[0],SIS6[0],SIS7[0],SIS8[0],SIS9[0],SIS10[0])

"""***Población infectada - Modelo SIS***"""

distribution_graph(SIS1[1],SIS2[1],SIS3[1],SIS4[1],SIS5[1],SIS6[1],SIS7[1],SIS8[1],SIS9[1],SIS10[1])

"""***Población susceptible - Modelo SIR***"""

distribution_graph(SIR1[0],SIR2[0],SIR3[0],SIR4[0],SIR5[0],SIR6[0],SIR7[0],SIR8[0],SIR9[0],SIR10[0])

"""***Población infectada - Modelo SIR***"""

distribution_graph(SIR1[2],SIR2[2],SIR3[2],SIR4[2],SIR5[2],SIR6[2],SIR7[2],SIR8[2],SIR9[2],SIR10[2])

"""***Población recuperada - Modelo SIR***"""

distribution_graph(SIR1[1],SIR2[1],SIR3[1],SIR4[1],SIR5[1],SIR6[1],SIR7[1],SIR8[1],SIR9[1],SIR10[1])

"""### Curvas promedio de los modelos epidemiológicos

En esta sección nos centraremos en analizar las curvas promedios para ambos modelos, $SIS$ y $SIR$. Esto nos permitirá concluir un resultado que no dependerá de una condición inicial, si no de un conjunto de condiciones para el cual las curvas tienden a una particular.
"""

def medium_curves_sis(alpha,beta,tf,csim,I0,A):     #Promedio de csim simulaciones para el modelo SIS
    S=[]; I=[]                                      #S e I guardarán el promedio de las cantidades normalizadas por estados respectivos
    cs=[]; ci=[]                                    #cs y ci serán las listas que permiten promediar la cantidad de individuos para csim simulaciones
    CI=np.zeros((tf,2)); CS=np.zeros((tf,2))        #Hay tf coordenadas
    for i in range(csim):                                          #Para csim simulaciones 
        promsis=SIS_model(alpha,beta,tf,initial_condition(I0,A))   #Aplique un condición inicial de distribución uniforme de infectados 
        cs.append(promsis[2]); ci.append(promsis[3])               #Las listas S e I generadas por cada iteración son enviadas a las listas cs y ci
    for i in range(tf):                                            #Se promedian las cantidades
        k=0; l=0
        for j in range(csim):
            k=k+cs[j][i]/csim; l=l+ci[j][i]/csim 
        S.append(k); I.append(l)                    #Las cantidades promedio son enviadas a las listas S e I
    for i in range(tf):                             #Se crean las listas de coordenadas
        CS[i][0]=i; CS[i][1]=S[i]
        CI[i][0]=i; CI[i][1]=I[i]
    return [CS,CI,S,I]                              #Datos promedio del modelo SIS para csim simulaciones

def graph_medium_curves_sis(alpha,beta,tf,csim,I0,A):   #Grafica del promedio de simulaciones para el modelo SIS
    SIS=medium_curves_sis(alpha,beta,tf,csim,I0,A)
    two_states_graph(SIS[0],SIS[1],"susceptibles","infectados","Curva promedio - Modelo SIS")

#A=np.zeros((30,30))
#graph_medium_curves_sis(0.2,0.5,50,10,0.1,A)

def medium_curves_sir(alpha,beta,tf,csim,I0,A):                   #Promedio de csim simulaciones para el modelo SIR
    S=[]; I=[]; R=[]                                              #S,I y R guardarán el promedio de las cantidades normalizadas por estados respectivos
    cs=[]; ci=[]; cr=[]                                           #cs,ci y cr serán las listas que permiten promediar la cantidad de individuos para csim simulaciones
    CI=np.zeros((tf,2)); CS=np.zeros((tf,2)); CR=np.zeros((tf,2)) #Hay tf coordenadas
    for i in range(csim):                                                   #Para csim simulaciones
        promsir=SIR_model(alpha,beta,tf,initial_condition(I0,A))            #Aplique un condición inicial de distribución uniforme de infectados 
        cs.append(promsir[3]); ci.append(promsir[4]); cr.append(promsir[5]) #Las listas S, I y R generadas por cada iteración son enviadas a las listas cs, ci y cr
    for i in range(tf):                                                     #Se promedian las cantidades
        k=0; l=0; p=0
        for j in range(csim):
            k=k+cs[j][i]; l=l+ci[j][i]; p=p+cr[j][i]
        k=k/csim; l=l/csim; p=p/csim 
        S.append(k); I.append(l); R.append(p)                      #Las cantidades promedio son enviadas a las listas S, I y R
    for i in range(tf):                                            #Se crean las listas de coordenadas
        CS[i][0]=i; CS[i][1]=S[i]
        CI[i][0]=i; CI[i][1]=I[i]
        CR[i][0]=i; CR[i][1]=R[i]
    return [CS,CR,CI,S,I,R]                                        #Datos promedio del modelo SIR para csim simulaciones

def graph_medium_curves_sir(alpha,beta,tf,csim,I0,A):        #Grafica del promedio de simulaciones para el modelo SIR
    SIR=medium_curves_sir(alpha,beta,tf,csim,I0,A)
    three_states_graph(SIR[0],SIR[1],SIR[2],"Susceptibles","Recuperados","Infectados","Curva promedio - Modelo SIR")

#A=np.zeros((30,30))
#graph_medium_curves_sir(0.2,0.5,50,10,0.1,A)

"""### Variaciones en las condiciones de frontera"""

def boundary(L,M):            #La lista L posee las coordenadas que definen las posiciones nulas en el sistema M 
    n,m=M.shape
    K=np.ones((n,m))
    for i in range(n):
        for j in range(m):
            K[i][j]=M[i][j]
    for i in range(len(L)):   #Para cada coordenada
        K[L[i][0],L[i][1]]=0  #Cambie la posición respectiva de la matriz M por cero
    return K                  #Retorne el sistema M

def domain_definition(n,m,a,b,M):   #Ubica una matriz nula de tamaño nxm en la posición a,b de M
    L=[]                            #Lista de coordenadas que se anularán 
    for i in range(n):      
        for j in range(m):
            L.append((a+i,b+j))     #Ingrese a la lista L las coordenadas de las posiciones de la submatriz nula
    return boundary(L,M)            #Reemplace las nxm posiciones de M por ceros en las posiciones a,b

"""A continuación haremos un estudio detallado de algunas superficies que permitirán describir propiedades importantes en la investigación.

Considere una enfermedad en la cual las tasas de infección y recuperación sean $\beta=0.5$ y $\alpha=0.2$ respectivamente. Analice el comportamiento de la enfermedad en un periodo de $30$ tics para las condiciones de frontera que se analizan en las siguientes secciones.

#### Análisis en una linea
"""

#L=np.zeros((1,10))
#L=initial_condition(0.1,L)
#plt.imshow(color(L),cmap="nipy_spectral", interpolation='nearest')

"""##### Modelo $SIS$"""

#heatmap_sis(0.2,0.5,30,L)

#graph_sis(0.2,0.5,30,L)

#Lprom=np.zeros((1,10))
#graph_medium_curves_sis(0.2,0.5,30,100,0.1,Lprom)

"""##### Modelo $SIR$"""

#heatmap_sir_I(0.2,0.5,30,L)

#heatmap_sir_R(0.2,0.5,30,L)

#graph_sir(0.2,0.5,30,L)

#graph_medium_curves_sir(0.2,0.5,30,100,0.1,Lprom)

"""#### Análisis en una región cuadrada"""

#C=np.zeros((10,10))
#C=initial_condition(0.1,C)
#plt.imshow(color(C),cmap="nipy_spectral", interpolation='nearest')

"""##### Modelo $SIS$"""

#heatmap_sis(0.2,0.5,30,C)

#graph_sis(0.2,0.5,30,C)

#Cprom=np.zeros((10,10))
#graph_medium_curves_sis(0.2,0.5,30,100,0.1,Cprom)

"""##### Modelo $SIR$"""

#heatmap_sir_I(0.2,0.5,30,C)

#heatmap_sir_R(0.2,0.5,30,C)

#graph_sir(0.2,0.5,30,C)

#graph_medium_curves_sir(0.2,0.5,30,100,0.1,Cprom)

"""#### Análisis en una región rectangular"""

#Re=np.zeros((10,30))
#Re=initial_condition(0.1,Re)
#plt.imshow(color(Re),cmap="nipy_spectral", interpolation='nearest')

"""##### Modelo $SIS$"""

#heatmap_sis(0.2,0.5,30,Re)

#graph_sis(0.2,0.5,30,Re)

#Reprom=np.zeros((10,30))
#graph_medium_curves_sis(0.2,0.5,30,100,0.1,Reprom)

"""##### Modelo $SIR$"""

#heatmap_sir_I(0.2,0.5,30,Re)

#heatmap_sir_R(0.2,0.5,30,Re)

#graph_sir(0.2,0.5,30,Re)

#graph_medium_curves_sir(0.2,0.5,30,100,0.1,Re)

"""#### Análisis en un rombo"""

def rombo(B,a,b,c,d):           #Rombo de diagonal mayor igual al doble de diagonal menor
    L=[B]
    i=0
    while c>1:
        a=a+2; b=b-4; c=c-1; d=d+2; i=i+1
        L.append(domain_definition(a,b,c,d,L[i-1]))
    return L[i]

#Ro=-np.ones((9,14))
#Ro=rombo(Ro,1,14,4,0)
#Ro=initial_condition(0.10,Ro)
#plt.imshow(color(Ro),cmap="nipy_spectral", interpolation='nearest')

"""##### Modelo $SIS$"""

#heatmap_sis(0.2,0.5,30,Ro)

#graph_sis(0.2,0.5,30,Ro)

#Roprom=-np.ones((10,16))
#Roprom=rombo(Roprom,2,14,4,1)
#graph_medium_curves_sis(0.2,0.5,30,100,0.1,Roprom)

"""##### Modelo $SIR$"""

#heatmap_sir_I(0.2,0.5,30,Ro)

#heatmap_sir_R(0.2,0.5,30,Ro)

#graph_sir(0.2,0.5,30,Ro)

#graph_medium_curves_sir(0.2,0.5,30,100,0.1,Roprom)

"""#### Análisis en un triángulo"""

def triangulo(n,m,a,b,M):
    L=[M]
    i=0
    while m>=1:
        i=i+1
        L.append(domain_definition(n,m,a,b,L[i-1]))
        m=m-2; a=a-1; b=b+1
    return L[i]

#T=-np.ones((10,19))
#T=triangulo(1,19,9,0,T)
#T=initial_condition(0.10,T)
#plt.imshow(color(T),cmap="nipy_spectral", interpolation='nearest')

"""##### Modelo $SIS$"""

#heatmap_sis(0.2,0.5,30,T)

#graph_sis(0.2,0.5,30,T)

#Tprom=-np.ones((10,19))
#Tprom=triangulo(1,19,9,0,Tprom)
#graph_medium_curves_sis(0.2,0.5,30,100,0.1,Tprom)

"""##### Modelo $SIR$"""

#heatmap_sir_I(0.2,0.5,30,T)

#heatmap_sir_R(0.2,0.5,30,T)

#graph_sir(0.2,0.5,30,T)

#graph_medium_curves_sir(0.2,0.5,30,100,0.1,Tprom)

"""#### Análisis en caso particular $\#1$"""

#CP1=-np.ones((8,8))
#CP12=domain_definition(2,8,0,0,CP1)
#CP13=domain_definition(8,2,0,0,CP12)
#CP14=domain_definition(8,2,0,6,CP13)
#CP15=domain_definition(2,8,6,0,CP14)
#CP15=initial_condition(0.1,CP15)
#plt.imshow(color(CP15),cmap="nipy_spectral", interpolation='nearest')

"""##### Modelo $SIS$"""

#heatmap_sis(0.2,0.5,30,CP1)

#graph_sis(0.2,0.5,30,CP1)

#CP1prom=-np.ones((8,8))
#CP12prom=domain_definition(2,8,0,0,CP1prom)
#CP13prom=domain_definition(8,2,0,0,CP12prom)
#CP14prom=domain_definition(8,2,0,6,CP13prom)
#CP15prom=domain_definition(2,8,6,0,CP14prom)
#graph_medium_curves_sis(0.2,0.5,30,100,0.1,CP15prom)

"""##### Modelo $SIR$"""

#heatmap_sir_I(0.2,0.5,30,CP1)

#heatmap_sir_R(0.2,0.5,30,CP1)

#graph_sir(0.2,0.5,30,CP1)

#graph_medium_curves_sir(0.2,0.5,30,100,0.1,CP15prom)

"""#### Análisis en caso particular $\#2$"""

#CP2=domain_definition(2,2,3,3,CP15)
#CP2=initial_condition(0.1,CP2)
#plt.imshow(color(CP2),cmap="nipy_spectral", interpolation='nearest')

"""##### Modelo $SIS$"""

#heatmap_sis(0.2,0.5,30,CP2)

#graph_sis(0.2,0.5,30,CP2)

#CP2prom=domain_definition(2,2,3,3,CP1prom)
#graph_medium_curves_sis(0.2,0.5,30,100,0.1,CP2prom)

"""##### Modelo $SIR$"""

#heatmap_sir_I(0.2,0.5,30,CP2)

#heatmap_sir_R(0.2,0.5,30,CP2)

#graph_sir(0.2,0.5,30,CP2)

#graph_medium_curves_sir(0.2,0.5,30,100,0.1,CP2prom)

"""#### Comparación"""

#SISL=medium_curves_sis(0.2,0.5,30,100,0.1,Lprom)
#SISC=medium_curves_sis(0.2,0.5,30,100,0.1,Cprom)
#SISRe=medium_curves_sis(0.2,0.5,30,100,0.1,Reprom)
#SISRo=medium_curves_sis(0.2,0.5,30,100,0.1,Roprom)
#SIST=medium_curves_sis(0.2,0.5,30,100,0.1,Tprom)
#SISCP1=medium_curves_sis(0.2,0.5,30,100,0.1,CP1prom)
#SISCP2=medium_curves_sis(0.2,0.5,30,100,0.1,CP2prom)

#SIRL=medium_curves_sir(0.2,0.5,30,100,0.1,Lprom)
#SIRC=medium_curves_sir(0.2,0.5,30,100,0.1,Cprom)
#SIRRe=medium_curves_sir(0.2,0.5,30,100,0.1,Reprom)
#SIRRo=medium_curves_sir(0.2,0.5,30,100,0.1,Roprom)
#SIRT=medium_curves_sir(0.2,0.5,30,100,0.1,Tprom)
#SIRCP1=medium_curves_sir(0.2,0.5,30,100,0.1,CP1prom)
#SIRCP2=medium_curves_sir(0.2,0.5,30,100,0.1,CP2prom)

#systems_graph(SIRL[2],SIRC[2],SIRRe[2],SIRRo[2],SIRT[2],SIRCP1[2],SIRCP2[2])

#systems_graph(SISL[1],SISC[1],SISRe[1],SISRo[1],SIST[1],SISCP1[1],SISCP2[1])

"""### Cambio de escala

En esta seccióón estudiaremos el factor de escala, la manera en la que afecta las soluciones de las diferentes regiones que se analizarón previamente.

En cada región se realizarón $5$ cambios de escala, donde se analizó una enfermedad de parámetros $\alpha=0.2$ y $\beta=0.5$ en un periodo de $30$ tics.
"""

def scale_differences(L1,L2):
    L=np.zeros((len(L1),2))
    for i in range(len(L1)):
        L[i][0]=i; L[i][1]=abs(L1[i]-L2[i])
    return L

"""#### Análisis en la linea"""

#L1=np.zeros((1,100))
#plt.imshow(color(L1),cmap="nipy_spectral", interpolation='nearest')

#SISL1=medium_curves_sis(0.2,0.5,30,100,0.1,L1)
#SIRL1=medium_curves_sir(0.2,0.5,30,100,0.1,L1)

#L2=np.zeros((1,200))
#plt.imshow(color(L2),cmap="nipy_spectral", interpolation='nearest')

#SISL2=medium_curves_sis(0.2,0.5,30,100,0.1,L2)
#SIRL2=medium_curves_sir(0.2,0.5,30,100,0.1,L2)

#L3=np.zeros((1,300))
#plt.imshow(color(L3),cmap="nipy_spectral", interpolation='nearest')

#SISL3=medium_curves_sis(0.2,0.5,30,100,0.1,L3)
#SIRL3=medium_curves_sir(0.2,0.5,30,100,0.1,L3)

#L4=np.zeros((1,400))
#plt.imshow(color(L4),cmap="nipy_spectral", interpolation='nearest')

#SISL4=medium_curves_sis(0.2,0.5,30,100,0.1,L4)
#SIRL4=medium_curves_sir(0.2,0.5,30,100,0.1,L4)

#L5=-np.zeros((1,500))
#plt.imshow(color(L5),cmap="nipy_spectral", interpolation='nearest')

#SISL5=medium_curves_sis(0.2,0.5,30,100,0.1,L5)
#SIRL5=medium_curves_sir(0.2,0.5,30,100,0.1,L5)

#scales_graph(SISL1[1],SISL2[1],SISL3[1],SISL4[1],SISL5[1])

#scales_graph(SIRL1[2],SIRL2[2],SIRL3[2],SIRL4[2],SIRL5[2])

#scales_difference_graph(grafdif(SISL1[3],SISL5[3]),grafdif(SISL2[3],SISL5[3]),grafdif(SISL3[3],SISL5[3]),grafdif(SISL4[3],SISL5[3]))

#scales_difference_graph(grafdif(SIRL1[3],SIRL5[3]),grafdif(SIRL2[3],SIRL5[3]),grafdif(SIRL3[3],SIRL5[3]),grafdif(SIRL4[3],SIRL5[3]))

"""#### Análisis en una región cuadrada"""

#C1=np.zeros((10,10))
#plt.imshow(color(C1),cmap="nipy_spectral", interpolation='nearest')

#SISC1=medium_curves_sis(0.2,0.5,30,100,0.1,C1)
#SIRC1=medium_curves_sir(0.2,0.5,30,100,0.1,C1)

#C2=np.zeros((25,25))
#plt.imshow(color(C2),cmap="nipy_spectral", interpolation='nearest')

#SISC2=medium_curves_sis(0.2,0.5,30,100,0.1,C2)
#SIRC2=medium_curves_sir(0.2,0.5,30,100,0.1,C2)

#C3=np.zeros((50,50))
#plt.imshow(color(C3),cmap="nipy_spectral", interpolation='nearest')

#SISC3=medium_curves_sis(0.2,0.5,30,100,0.1,C3)
#SIRC3=medium_curves_sir(0.2,0.5,30,100,0.1,C3)

#C4=np.zeros((75,75))
#plt.imshow(color(C4),cmap="nipy_spectral", interpolation='nearest')

#SISC4=medium_curves_sis(0.2,0.5,30,100,0.1,C4)
#SIRC4=medium_curves_sir(0.2,0.5,30,100,0.1,C4)

#C5=np.zeros((100,100))
#plt.imshow(color(C5),cmap="nipy_spectral", interpolation='nearest')

#SISC5=medium_curves_sis(0.2,0.5,30,100,0.1,C5)
#SIRC5=medium_curves_sir(0.2,0.5,30,100,0.1,C5)

#scales_graph(SISC1[1],SISC2[1],SISC3[1],SISC4[1],SISC5[1])

#scales_graph(SIRC1[2],SIRC2[2],SIRC3[2],SIRC4[2],SIRC5[2])

#scales_difference_graph(grafdif(SISC1[3],SISC5[3]),grafdif(SISC2[3],SISC5[3]),grafdif(SISC3[3],SISC5[3]),grafdif(SISC4[3],SISC5[3]))

#scales_difference_graph(grafdif(SIRC1[3],SIRC5[3]),grafdif(SIRC2[3],SIRC5[3]),grafdif(SIRC3[3],SIRC5[3]),grafdif(SIRC4[3],SIRC5[3]))

"""#### Análisis en una región rectángular"""

#Re1=np.zeros((5,20))
#plt.imshow(color(Re1),cmap="nipy_spectral", interpolation='nearest')

#SISRe1=medium_curves_sis(0.2,0.5,30,100,0.1,Re1)
#SIRRe1=medium_curves_sir(0.2,0.5,30,100,0.1,Re1)

#Re2=np.zeros((13,52))
#plt.imshow(color(Re2),cmap="nipy_spectral", interpolation='nearest')

#SISRe2=medium_curves_sis(0.2,0.5,30,100,0.1,Re2)
#SIRRe2=medium_curves_sir(0.2,0.5,30,100,0.1,Re2)

#Re3=np.zeros((25,100))
#plt.imshow(color(Re3),cmap="nipy_spectral", interpolation='nearest')

#SISRe3=medium_curves_sis(0.2,0.5,30,100,0.1,Re3)
#SIRRe3=medium_curves_sir(0.2,0.5,30,100,0.1,Re3)

#Re4=np.zeros((38,152))
#plt.imshow(color(Re4),cmap="nipy_spectral", interpolation='nearest')

#SISRe4=medium_curves_sis(0.2,0.5,30,100,0.1,Re4)
#SIRRe4=medium_curves_sir(0.2,0.5,30,100,0.1,Re4)

#Re5=np.zeros((50,200))
#plt.imshow(color(Re5),cmap="nipy_spectral", interpolation='nearest')

#SISRe5=medium_curves_sis(0.2,0.5,30,100,0.1,Re5)
#SIRRe5=medium_curves_sir(0.2,0.5,30,100,0.1,Re5)

#scales_graph(SISRe1[1],SISRe2[1],SISRe3[1],SISRe4[1],SISRe5[1])

#scales_graph(SIRRe1[2],SIRRe2[2],SIRRe3[2],SIRRe4[2],SIRRe5[2])

#scales_difference_graph(grafdif(SISRe1[3],SISRe5[3]),grafdif(SISRe2[3],SISRe5[3]),grafdif(SISRe3[3],SISRe5[3]),grafdif(SISRe4[3],SISRe5[3]))

#scales_difference_graph(grafdif(SIRRe1[3],SIRRe5[3]),grafdif(SIRRe2[3],SIRRe5[3]),grafdif(SIRRe3[3],SIRRe5[3]),grafdif(SIRRe4[3],SIRRe5[3]))

"""#### Análisis en una región tipo rombo"""

#Ro1=-np.ones((11,20))
#Ro1=rombo(Ro1,1,20,5,0)
#plt.imshow(color(Ro1),cmap="nipy_spectral", interpolation='nearest')

#SISRo1=medium_curves_sis(0.2,0.5,30,100,0.1,Ro1)
#SIRRo1=medium_curves_sir(0.2,0.5,30,100,0.1,Ro1)

#Ro2=-np.ones((32,50))
#Ro2=rombo(Ro2,1,50,16,0)
#plt.imshow(color(Ro2),cmap="nipy_spectral", interpolation='nearest')

#SISRo2=medium_curves_sis(0.2,0.5,30,100,0.1,Ro2)
#SIRRo2=medium_curves_sir(0.2,0.5,30,100,0.1,Ro2)

#Ro3=-np.ones((60,100))
#Ro3=rombo(Ro3,1,100,30,1)
#plt.imshow(color(Ro3),cmap="nipy_spectral", interpolation='nearest')

#SISRo3=medium_curves_sis(0.2,0.5,30,100,0.1,Ro3)
#SIRRo3=medium_curves_sir(0.2,0.5,30,100,0.1,Ro3)

#Ro4=-np.ones((80,150))
#Ro4=rombo(Ro4,1,150,40,0)
#plt.imshow(color(Ro4),cmap="nipy_spectral", interpolation='nearest')

#SISRo4=medium_curves_sis(0.2,0.5,30,100,0.1,Ro4)
#SIRRo4=medium_curves_sir(0.2,0.5,30,100,0.1,Ro4)

#Ro5=-np.ones((110,200))
#Ro5=rombo(Ro5,1,200,55,0)
#plt.imshow(color(Ro5),cmap="nipy_spectral", interpolation='nearest')

#SISRo5=medium_curves_sis(0.2,0.5,30,100,0.1,Ro5)
#SIRRo5=medium_curves_sir(0.2,0.5,30,100,0.1,Ro5)

#scales_graph(SISRo1[1],SISRo2[1],SISRo3[1],SISRo4[1],SISRo5[1])

#scales_graph(SIRRo1[2],SIRRo2[2],SIRRo3[2],SIRRo4[2],SIRRo5[2])

#scales_difference_graph(grafdif(SISRo1[3],SISRo5[3]),grafdif(SISRo2[3],SISRo5[3]),grafdif(SISRo3[3],SISRo5[3]),grafdif(SISRo4[3],SISRo5[3]))

#scales_difference_graph(grafdif(SIRRo1[3],SIRRo5[3]),grafdif(SIRRo2[3],SIRRo5[3]),grafdif(SIRRo3[3],SIRRo5[3]),grafdif(SIRRo4[3],SIRRo5[3]))

"""#### Análisis en un triangulo"""

#T1=-np.ones((10,19))
#T1=triangulo(1,19,9,0,T1)
#plt.imshow(color(T1),cmap="nipy_spectral", interpolation='nearest')

#SIST1=medium_curves_sis(0.2,0.5,30,100,0.1,T1)
#SIRT1=medium_curves_sir(0.2,0.5,30,100,0.1,T1)

#T2=-np.ones((25,49))
#T2=triangulo(1,49,24,0,T2)
#plt.imshow(color(T2),cmap="nipy_spectral", interpolation='nearest')

#SIST2=medium_curves_sis(0.2,0.5,30,100,0.1,T2)
#SIRT2=medium_curves_sir(0.2,0.5,30,100,0.1,T2)

#T3=-np.ones((50,99))
#T3=triangulo(1,99,49,0,T3)
#plt.imshow(color(T3),cmap="nipy_spectral", interpolation='nearest')

#SIST3=medium_curves_sis(0.2,0.5,30,100,0.1,T3)
#SIRT3=medium_curves_sir(0.2,0.5,30,100,0.1,T3)

#T4=-np.ones((75,149))
#T4=triangulo(1,149,74,0,T4)
#plt.imshow(color(T4),cmap="nipy_spectral", interpolation='nearest')

#SIST4=medium_curves_sis(0.2,0.5,30,100,0.1,T4)
#SIRT4=medium_curves_sir(0.2,0.5,30,100,0.1,T4)

#T5=-np.ones((100,199))
#T5=triangulo(1,199,99,0,T5)
#plt.imshow(color(T5),cmap="nipy_spectral", interpolation='nearest')

#SIST5=medium_curves_sis(0.2,0.5,30,100,0.1,T5)
#SIRT5=medium_curves_sir(0.2,0.5,30,100,0.1,T5)

#scales_graph(SIST1[1],SIST2[1],SIST3[1],SIST4[1],SIST5[1])

#scales_graph(SIRT1[2],SIRT2[2],SIRT3[2],SIRT4[2],SIRT5[2])

#scales_difference_graph(grafdif(SIST1[3],SIST5[3]),grafdif(SIST2[3],SIST5[3]),grafdif(SIST3[3],SIST5[3]),grafdif(SIST4[3],SIST5[3]))

#scales_difference_graph(grafdif(SIRT1[3],SIRT5[3]),grafdif(SIRT2[3],SIRT5[3]),grafdif(SIRT3[3],SIRT5[3]),grafdif(SIRT4[3],SIRT5[3]))

#scales_graph(SISL5[1],SISC5[1],SISRe5[1],SISRo5[1],SIST5[1])

#scales_graph(SIRL5[2],SIRC5[2],SIRRe5[2],SIRRo5[2],SIRT5[2])

"""### Modelos SIS & SIR con natalidad mortalidad"""

def three_states_graph_2(A,B,C,titulo): #Gráfica de estados
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C)
    x=[]; y=[]; z=[]; w=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
  
    plt.plot(x, y, c='y', label="Susceptibles")
    plt.plot(x, z, c='r', label="Infectados")
    plt.plot(x, w, 'b--', label="Muertos")
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title(str(titulo))
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def four_states_graph(A,B,C,D,titulo): #Gráfica de estados
    cond=[]             
    funcion=[]
    SA=spline3(A); SB=spline3(B); SC=spline3(C); SD=spline3(D)
    x=[]; y=[]; z=[]; w=[]; t=[]; l=[]
    for i in range(len(spline3(A))):
        xa=np.linspace(A[i,0],A[i+1,0]-0.0001,11)
        x=np.concatenate((x,xa))
        ya=SA[i,0]+SA[i,1]*(xa-A[i,0])+SA[i,2]*(xa-A[i,0])**2+SA[i,3]*(xa-A[i,0])**3
        y=np.concatenate((y,ya))
        za=SB[i,0]+SB[i,1]*(xa-B[i,0])+SB[i,2]*(xa-B[i,0])**2+SB[i,3]*(xa-B[i,0])**3
        z=np.concatenate((z,za))
        wa=SC[i,0]+SC[i,1]*(xa-C[i,0])+SC[i,2]*(xa-C[i,0])**2+SC[i,3]*(xa-C[i,0])**3
        w=np.concatenate((w,wa))
        ta=SD[i,0]+SD[i,1]*(xa-D[i,0])+SD[i,2]*(xa-D[i,0])**2+SD[i,3]*(xa-D[i,0])**3
        t=np.concatenate((t,ta))
  
    plt.plot(x, y, c='y', label="Susceptibles")
    plt.plot(x, z, c='r', label="Infectados")
    plt.plot(x, w, c='g', label="Recuperados")
    plt.plot(x, t, 'b--', label="Muertos")
    plt.plot(x, x**0, 'k--')
    plt.legend(loc=0)
    plt.title(str(titulo))
    plt.xlabel('Tiempo')
    plt.ylim(0,1.05)
    plt.show()

def edades(A):
    n,m=A.shape
    Ci=num_individuals(A)
    Ni=[0]*math.ceil(0.23*Ci)
    Ad=[0]*math.ceil(0.68*Ci)
    Vi=[0]*math.ceil(0.09*Ci)
    for i in range(len(Ni)):
        Ni[i]=random.randint(1,14)
    for i in range(len(Ad)):
        Ad[i]=random.randint(15,64)
    for i in range(len(Vi)):
        Vi[i]=random.randint(65,100)
    Ed=Ni+Ad+Vi
    E=-np.ones((n,m))
    for i in range(n):
        for j in range(m):
            if A[i,j]!=-1 and A[i,j]!=3:
                p=random.choice(Ed)
                E[i,j]=p
            elif A[i,j]==3:
                E[i,j]=0
    return E

vm=[0.0178,0.00124,0.00134,0.003645,0.00598,0.006045,0.006445,0.00788,0.01015,0.014695,0.02253,0.03427,0.054225,0.08721,0.1386950,0.219845,0.368005]

def vector_edad(l,h,A):
    n,m=A.shape
    E=[]
    for i in range(n):
        for j in range(m):
            if l<A[i][j] and A[i][j]<h:
                E.append([i,j])
    return E

def evoE(vm,E,d,y):
    n,m=E.shape
    E1=np.zeros((n,m))
    for i in range(n):
        for j in range(m):
            if E[i][j]!=0 and d==y or d==2*y or d==3*y:
                E1[i][j]=E[i][j]+1
            elif E[i][j]>=90:
                E1[i][j]=0
            elif E[i,j]==0:
                p=random.randint(0,100)
                if p<0:       #Debe ir p<2
                    E1[i][j]=1
            elif E[i,j]==-1:
                E1[i,j]=-1
            else:
                E1[i,j]=E[i,j]
    N=[]; a=[]
    N1=vector_edad(0,5,E); a1=math.ceil(len(N1)*vm[0])-1; N.append(N1); a.append(a1)
    N2=vector_edad(4,10,E); a2=math.ceil(len(N2)*vm[1])-1; N.append(N2); a.append(a2)
    N3=vector_edad(9,15,E); a3=math.ceil(len(N3)*vm[2])-1; N.append(N3); a.append(a3)
    N4=vector_edad(14,20,E); a4=math.ceil(len(N4)*vm[3])-1; N.append(N4); a.append(a4)
    N5=vector_edad(19,25,E); a5=math.ceil(len(N5)*vm[4])-1; N.append(N5); a.append(a5)
    N6=vector_edad(24,30,E); a6=math.ceil(len(N6)*vm[5])-1; N.append(N6); a.append(a6)
    N7=vector_edad(29,35,E); a7=math.ceil(len(N7)*vm[6])-1; N.append(N7); a.append(a7)
    N8=vector_edad(34,40,E); a8=math.ceil(len(N8)*vm[7])-1; N.append(N8); a.append(a8)
    N9=vector_edad(39,45,E); a9=math.ceil(len(N9)*vm[8])-1; N.append(N9); a.append(a9)
    N10=vector_edad(44,50,E); a10=math.ceil(len(N10)*vm[9])-1; N.append(N10); a.append(a10)
    N11=vector_edad(49,55,E); a11=math.ceil(len(N11)*vm[10])-1; N.append(N11); a.append(a11)
    N12=vector_edad(54,60,E); a12=math.ceil(len(N12)*vm[11])-1; N.append(N12); a.append(a12)
    N13=vector_edad(59,65,E); a13=math.ceil(len(N13)*vm[12])-1; N.append(N13); a.append(a13)
    N14=vector_edad(64,70,E); a14=math.ceil(len(N14)*vm[13])-1; N.append(N14); a.append(a14)
    N15=vector_edad(69,75,E); a15=math.ceil(len(N15)*vm[14])-1; N.append(N15); a.append(a15)
    N16=vector_edad(74,80,E); a16=math.ceil(len(N16)*vm[15])-1; N.append(N16); a.append(a16)
    N17=vector_edad(79,100,E); a17=math.ceil(len(N17)*vm[16])-1; N.append(N17); a.append(a17)
    v=[]
    for i in range(len(a)):
        for j in range(a[i]):
            b=random.randint(0,len(N[i])-1)
            v.append(N[i][b])
    for i in range(len(v)):
        E1[v[i][0]][v[i][1]]=0
    return E1

def evolution_sis_cp(alpha,beta,A,E,d,y):
    Ed=evoE(vm,E,d,y)
    B=evolution_sis(alpha,beta,A)
    n,m=A.shape
    C=np.zeros((n,m))
    for i in range(n):
        for j in range(m):
            if Ed[i,j]==0:
                C[i,j]=3
            elif Ed[i,j]==1:
                C[i,j]=0
            else:
                C[i,j]=B[i,j]
    return [C,Ed]

def evolution_sir_cp(alpha,beta,A,E,d,y):
    Ed=evoE(vm,E,d,y)
    B=evolution_sir(alpha,beta,A)
    n,m=A.shape
    C=np.zeros((n,m))
    for i in range(n):
        for j in range(m):
            if A[i,j]==75:
                C[i,j]=75
            if Ed[i,j]==0:
                C[i,j]=3
            elif Ed[i,j]==1:
                C[i,j]=0
            else:
                C[i,j]=B[i,j]
    return [C,Ed]

def evolution_SIS_cp(alpha,beta,tf,A,E,y):
    L=[A]
    Ed=[E]
    i = 0                                 
    while i <= tf:                        
        i = i + 1     
        A=evolution_sis_cp(alpha,beta,L[i-1],Ed[i-1],i,y)
        L.append(A[0])
        Ed.append(A[1])
    return L

def evolution_SIR_cp(alpha,beta,tf,A,E,y):
    L=[A]
    Ed=[E]
    i = 0                                 
    while i <= tf:                        
        i = i + 1     
        A=evolution_sir_cp(alpha,beta,L[i-1],Ed[i-1],i,y)
        L.append(A[0])
        Ed.append(A[1])
    return L

def SIS_cp_model(alpha,beta,tf,A,E,y):                      
    S = []; I = []; D = []                               
    CI = np.zeros((tf,2)); CS = np.zeros((tf,2)); CD = np.zeros((tf,2))   
    B = evolution_SIS_cp(alpha,beta,tf,A,E,y)                   
    for j in range(tf):                           
        M = B[j]                                    
        S.append(count_s(M))                       
        I.append(count_i(M))  
        D.append(count_d(M))
    for i in range(tf):                           
        CS[i][0] = i; CS[i][1] = S[i]               
        CI[i][0] = i; CI[i][1] = I[i] 
        CD[i][0] = i; CD[i][1] = D[i]  
    return [CS,CI,CD,S,I,D,B]

def SIR_cp_model(alpha,beta,tf,A,E,y):                      
    S = []; I = []; R = []; D = []                               
    CI = np.zeros((tf,2)); CS = np.zeros((tf,2)); CR = np.zeros((tf,2)); CD = np.zeros((tf,2))   
    B = evolution_SIR_cp(alpha,beta,tf,A,E,y)                   
    for j in range(tf):                           
        M = B[j]                                    
        S.append(count_s(M))                       
        I.append(count_i(M)) 
        R.append(count_r(M))  
        D.append(count_d(M))
    for i in range(tf):                           
        CS[i][0] = i; CS[i][1] = S[i]               
        CI[i][0] = i; CI[i][1] = I[i] 
        CR[i][0] = i; CR[i][1] = R[i]
        CD[i][0] = i; CD[i][1] = D[i]  
    return [CS,CR,CI,CD,S,I,R,D,B]

def graph_sis_cp(alpha,beta,tf,A,E,y):   
    SIS=SIS_cp_model(alpha,beta,tf,A,E,y)      
    three_states_graph_2(SIS[0],SIS[1],SIS[2], "Modelo SIR con tasa de natalidad/mortalidad (con pesos)")

def graph_sir_cp(alpha,beta,tf,A,E,y):   
    SIR=SIR_cp_model(alpha,beta,tf,A,E,y)      
    four_states_graph(SIR[0],SIR[2],SIR[1],SIR[3], "Modelo SIR con tasa de natalidad/mortalidad (con pesos)")

A=center(25,25,0.1)
E=edades(A)
graph_sir_cp(0.2,0.05,100,A,E,365)

"""### Modelos SIS & SIR con muerte por enfermedad"""

vme=[[0,20,0.0018],[19,40,0.0047],[39,60,0.0259],[59,80,0.1481],[80,105,0.3014]]

def evoME(vme,A,E):
    n,m=A.shape
    B=np.zeros((n,m))
    C=np.zeros((n,m))
    vecN=[]
    a=[]
    v=[]
    for i in range(n):
        for j in range(m):
            B[i,j]=E[i,j]
            C[i,j]=A[i,j]
    for i in range(len(vme)):
        N1=vector_edad(vme[i][0],vme[i][1],B)
        N2=[]
        for j in range(len(N1)):
            if A[N1[j][0],N1[j][1]]==1:
                N2.append(N1[j])
        ai=math.ceil(len(N2)*vme[i][2])-1
        vecN.append(N2); a.append(ai)
    for i in range(len(a)):
        for j in range(a[i]):
            b=random.randint(0,len(vecN[i])-1)
            v.append(vecN[i][b])
    for i in range(len(v)):
        B[v[i][0]][v[i][1]]=0
        C[v[i][0]][v[i][1]]=3
    return [C,B]

def evolution_sis_cm(alpha,beta,vme,A,E,d,y):
    n,m=A.shape
    B=np.zeros((n,m))
    C=evolution_sis_cp(alpha,beta,A,E,d,y)
    for i in range(n):
        for j in range(m):
            B[i,j]=C[0][i,j]
    D=evoME(vme,B,C[1])
    return D

def evolution_sir_cm(alpha,beta,vme,A,E,d,y):
    n,m=A.shape
    B=np.zeros((n,m))
    C=evolution_sir_cp(alpha,beta,A,E,d,y)
    for i in range(n):
        for j in range(m):
            B[i,j]=C[0][i,j]
    D=evoME(vme,B,C[1])
    return D

def evolution_SIS_cm(alpha,beta,tf,vme,A,E,y):          
    L = [A]
    Ed = [E]
    i = 0                                 
    while i <= tf:                        
        i = i + 1 
        B=evolution_sis_cm(alpha,beta,vme,L[i-1],Ed[i-1],i,y)
        L.append(B[0])
        Ed.append(B[1])
    return L

def evolution_SIR_cm(alpha,beta,tf,vme,A,E,y):          
    L = [A]
    Ed = [E]
    i = 0                                 
    while i <= tf:                        
        i = i + 1 
        B=evolution_sir_cm(alpha,beta,vme,L[i-1],Ed[i-1],i,y)
        L.append(B[0])
        Ed.append(B[1])
    return L

def SIS_cm_model(alpha,beta,tf,vme,A,E,y):     
    S=[]; I=[]; D=[]           
    CI=np.zeros((tf,2))           
    CS=np.zeros((tf,2)) 
    CD=np.zeros((tf,2))
    B=evolution_SIS_cm(alpha,beta,tf,vme,A,E,y)     
    for j in range(tf):          
        M=B[j]                     
        S.append(count_s(M))      
        I.append(count_i(M))  
        D.append(count_d(M))
    for i in range(tf):           
        CS[i][0]=i; CS[i][1]=S[i]   
        CI[i][0]=i; CI[i][1]=I[i]
        CD[i][0]=i; CD[i][1]=D[i]   
    return [CS,CI,CD,S,I,D,B]

def SIR_cm_model(alpha,beta,tf,vme,A,E,y):     
    S=[]; I=[]; R=[]; D=[]           
    CI=np.zeros((tf,2))           
    CS=np.zeros((tf,2))           
    CR=np.zeros((tf,2)) 
    CD=np.zeros((tf,2))
    B=evolution_SIR_cm(alpha,beta,tf,vme,A,E,y)     
    for j in range(tf):          
        M=B[j]                     
        S.append(count_s(M))      
        I.append(count_i(M))   
        R.append(count_r(M))  
        D.append(count_d(M))
    for i in range(tf):           
        CS[i][0]=i; CS[i][1]=S[i]   
        CI[i][0]=i; CI[i][1]=I[i]   
        CR[i][0]=i; CR[i][1]=R[i]
        CD[i][0]=i; CD[i][1]=D[i]   
    return [CS,CR,CI,CD,S,I,R,D,B]

def graph_sis_cm(alpha,beta,tf,vme,A,E,y):   
    SIS=SIS_cm_model(alpha,beta,tf,vme,A,E,y)      
    three_states_graph_2(SIS[0],SIS[1],SIS[2], "Modelo SIR con muerte por enfermedad")

def graph_sir_cm(alpha,beta,tf,vme,A,E,y):   
    SIR=SIR_cm_model(alpha,beta,tf,vme,A,E,y)      
    four_states_graph(SIR[0],SIR[2],SIR[1],SIR[3], "Modelo SIR con muerte por enfermedad")

def medium_curves_sis_cm(alpha,beta,tf,vme,csim,I0,A,E,y):                    #Promedio de csim simulaciones para el modelo SIS
    S=[]; I=[]; D=[]                                                        #S e I guardarán el promedio de las cantidades normalizadas por estados respectivos
    cs=[]; ci=[]; cd=[]                                                     #cs y ci serán las listas que permiten promediar la cantidad de individuos para csim simulaciones
    CI=np.zeros((tf,2)); CS=np.zeros((tf,2)); CD=np.zeros((tf,2))           #Hay tf coordenadas
    for i in range(csim):                                                   #Para csim simulaciones 
        promsis=SIS_cm_model(alpha,beta,tf,vme,initial_condition(I0,A),E,y)   #Aplique un condición inicial de distribución uniforme de infectados 
        cs.append(promsis[3]); ci.append(promsis[4]); cd.append(promsis[4]) #Las listas S e I generadas por cada iteración son enviadas a las listas cs y ci
    for i in range(tf):                                                     #Se promedian las cantidades
        k=0; l=0; m=0
        for j in range(csim):
            k=k+cs[j][i]/csim; l=l+ci[j][i]/csim; m=m+cd[j][i]/csim  
        S.append(k); I.append(l); D.append(m)       #Las cantidades promedio son enviadas a las listas S e I
    for i in range(tf):                             #Se crean las listas de coordenadas
        CS[i][0]=i; CS[i][1]=S[i]
        CI[i][0]=i; CI[i][1]=I[i]
        CD[i][0]=i; CD[i][1]=D[i]
    return [CS,CI,CD,S,I,D]                         #Datos promedio del modelo SIS para csim simulaciones

def graph_medium_curves_sis_cm(alpha,beta,tf,vme,csim,I0,A,E,y):   #Grafica del promedio de simulaciones para el modelo SIS
    SIS=medium_curves_sis_cm(alpha,beta,tf,vme,csim,I0,A,E,y)
    three_states_graph_2(SIS[0],SIS[1],SIS[2],"Curva promedio - Modelo SIS_CM")

def medium_curves_sir_cm(alpha,beta,tf,vme,csim,I0,A,E,y):                               #Promedio de csim simulaciones para el modelo SIR
    S=[]; I=[]; R=[]; D=[]                                                             #S,I y R guardarán el promedio de las cantidades normalizadas por estados respectivos
    cs=[]; ci=[]; cr=[]; cd=[]                                                         #cs,ci y cr serán las listas que permiten promediar la cantidad de individuos para csim simulaciones
    CI=np.zeros((tf,2)); CS=np.zeros((tf,2)); CR=np.zeros((tf,2)); CD=np.zeros((tf,2)) #Hay tf coordenadas
    for i in range(csim):                                                              #Para csim simulaciones
        promsir=SIR_cm_model(alpha,beta,tf,vme,initial_condition(I0,A),E,y)              #Aplique un condición inicial de distribución uniforme de infectados 
        cs.append(promsir[4]); ci.append(promsir[5]); cr.append(promsir[6]); cd.append(promsir[7]) #Las listas S, I y R generadas por cada iteración son enviadas a las listas cs, ci y cr
    for i in range(tf):                                                                            #Se promedian las cantidades
        k=0; l=0; p=0; m=0
        for j in range(csim):
            k=k+cs[j][i]; l=l+ci[j][i]; p=p+cr[j][i]; m=m+cd[j][i]
        k=k/csim; l=l/csim; p=p/csim;  m=m/csim 
        S.append(k); I.append(l); R.append(p); D.append(m)         #Las cantidades promedio son enviadas a las listas S, I y R
    for i in range(tf):                                            #Se crean las listas de coordenadas
        CS[i][0]=i; CS[i][1]=S[i]
        CI[i][0]=i; CI[i][1]=I[i]
        CR[i][0]=i; CR[i][1]=R[i]
        CD[i][0]=i; CD[i][1]=D[i]
    return [CS,CR,CI,CD,S,I,R,D]                                        #Datos promedio del modelo SIR para csim simulaciones

def graph_medium_curves_sir_cm(alpha,beta,tf,vme,csim,I0,A,E,y):        #Grafica del promedio de simulaciones para el modelo SIR
    SIR=medium_curves_sir_cm(alpha,beta,tf,vme,csim,I0,A,E,y)
    four_states_graph(SIR[0],SIR[2],SIR[1],SIR[3],"Curva promedio - Modelo SIR_CM")

def edades_cv(A):
    n,m=A.shape
    Ci=num_individuals(A)
    Ni=[0]*math.ceil(0.71*Ci)
    Ad=[0]*math.ceil(0.21*Ci)
    Vi=[0]*math.ceil(0.08*Ci)
    for i in range(len(Ni)):
        Ni[i]=random.randint(18,39)
    for i in range(len(Ad)):
        Ad[i]=random.randint(40,69)
    for i in range(len(Vi)):
        Vi[i]=random.randint(70,85)
    Ed=Ni+Ad+Vi
    E=-np.ones((n,m))
    for i in range(n):
        for j in range(m):
            if A[i,j]!=-1 and A[i,j]!=3:
                p=random.choice(Ed)
                E[i,j]=p
            elif A[i,j]==3:
                E[i,j]=0
    return E

A=np.zeros((42,42))
E=edades_cv(A)
graph_medium_curves_sir_cm(1/14,5.7/14,30,vme,100,0.17,A,E,365)

cv=-np.ones((80,71))
b1=domain_definition(8,5,65,64,cv)
b2=domain_definition(10,5,55,65,cv)
b3=domain_definition(4,4,50,64,cv)
b4=domain_definition(4,2,49,61,cv)
b5=domain_definition(4,9,50,51,cv)
b6=domain_definition(5,11,48,39,cv)
b7=domain_definition(6,22,41,40,cv)
b8=domain_definition(6,4,55,57,cv)
b9=domain_definition(10,6,55,50,cv); b9=domain_definition(7,2,58,48,b9); b9=domain_definition(3,4,58,45,b9)
b10=domain_definition(4,5,62,57,cv)
b11=domain_definition(5,7,70,55,cv); b11=domain_definition(4,2,71,53,b11)
b12=domain_definition(5,9,65,42,cv); b12=domain_definition(3,3,65,51,b12); b12=domain_definition(5,1,66,41,b12); b12=domain_definition(5,1,67,40,b12); b12=domain_definition(3,1,68,39,b12); b12=domain_definition(1,1,69,38,b12)
b13=domain_definition(1,4,64,38,cv); b13=domain_definition(1,2,63,39,b13); b13=domain_definition(1,4,65,37,b13); b13=domain_definition(1,4,66,36,b13); b13=domain_definition(1,4,67,35,b13); b13=domain_definition(1,4,68,34,b13); b13=domain_definition(1,2,69,35,b13)
b14=domain_definition(4,3,57,40,cv); b14=domain_definition(6,2,56,38,b14); b14=domain_definition(8,3,55,35,b14)
b15=domain_definition(7,10,34,37,cv)
b16=domain_definition(17,9,17,35,cv); b16=domain_definition(5,5,23,44,b16); b16=domain_definition(12,1,17,34,b16); b16=domain_definition(10,1,17,33,b16)
b17=domain_definition(3,11,75,21,cv)
b18=domain_definition(8,3,55,30,cv)
b19=domain_definition(5,6,66,26,cv)
b20=domain_definition(9,20,54,8,cv); b20=domain_definition(4,7,63,15,b20); b20=domain_definition(4,8,50,10,b20); b20=domain_definition(3,1,63,14,b20)
b21=domain_definition(3,2,60,28,cv)
b22=domain_definition(6,14,67,11,cv); b22=domain_definition(2,7,73,11,b22)
b23=domain_definition(6,4,47,4,cv)
b24=domain_definition(4,8,47,12,cv)

b25=domain_definition(13,1,38,23,cv); b25=domain_definition(5,1,44,22,b25); b25=domain_definition(1,1,46,21,b25)
b25=domain_definition(3,1,39,22,b25); b25=domain_definition(1,1,40,21,b25); b25=domain_definition(13,1,37,24,b25); b25=domain_definition(11,1,38,25,b25)
b25=domain_definition(9,1,39,26,b25); b25=domain_definition(7,1,40,27,b25); b25=domain_definition(7,1,39,28,b25); b25=domain_definition(7,1,38,29,b25)
b25=domain_definition(7,1,37,30,b25); b25=domain_definition(7,1,36,31,b25); b25=domain_definition(7,1,35,32,b25); b25=domain_definition(5,1,36,33,b25)
b25=domain_definition(3,1,37,34,b25); b25=domain_definition(1,1,38,35,b25)

b26=domain_definition(1,2,51,25,cv)
b27=domain_definition(4,3,48,28,cv)
b28=domain_definition(4,6,44,32,cv)
b29=domain_definition(6,4,30,5,cv); b29=domain_definition(6,4,32,9,b29)
b30=domain_definition(10,6,22,11,cv); b30=domain_definition(3,3,29,17,b30)
b31=domain_definition(6,10,12,18,cv)

def vecfun(A,k):
    n,m=A.shape
    v=[]
    for i in range(n):
        for j in range(m):
            if A[i,j]==k:
                v.append([i,j])
    return v

def transporte(A,B,E,pr1,pr2):
    n,m=A.shape
    A1=np.zeros((n,m)); B1=np.zeros((n,m)); E1=-np.ones((n,m))
    V1=[]
    for i in range(n):
        for j in range(m):
            A1[i,j]=A[i,j]
            B1[i,j]=B[i,j]
            E1[i,j]=E[i,j]
    for i in range(-1,4):
        V1.append(vecfun(A,i))
    V2=vecfun(B1,75)
    for i in range(1,len(V1)):
        if i!=2:
            for j in range(len(V1[i])):
                p=random.randint(0,100)
                if p<=pr1*100:
                    k=random.randint(0,len(V1[i])-1)
                    l=random.randint(0,len(V2)-1)
                    A1[V1[i][k][0]][V1[i][k][1]]=B1[V2[l][0]][V2[l][1]]
                    B1[V2[l][0]][V2[l][1]]=A[V1[i][k][0]][V1[i][k][1]]
                    E1[V1[i][k][0]][V1[i][k][1]]=E[V2[l][0]][V2[l][1]]
                    E[V2[l][0]][V2[l][1]]=-1
        else:
            for j in range(len(V1[i])):
                p=random.randint(0,100)
                if p<=pr2*100:
                    k=random.randint(0,len(V1[i])-1)
                    l=random.randint(0,len(V2)-1)
                    A1[V1[i][k][0]][V1[i][k][1]]=B1[V2[l][0]][V2[l][1]]
                    B1[V2[l][0]][V2[l][1]]=A[V1[i][k][0]][V1[i][k][1]]
                    E1[V1[i][k][0]][V1[i][k][1]]=E[V2[l][0]][V2[l][1]]
                    E[V2[l][0]][V2[l][1]]=-1
        V2=vecfun(B1,75)
    return [A1,B1,E1]

def superposicion(A,B):
    n,m=A.shape
    C=-np.ones((n,m))
    for i in range(n):
        for j in range(m):
            C[i,j]=A[i,j]
            if C[i,j]==-1:
                C[i,j]=B[i,j]
    return C

def evolution_sir_m(alpha,beta,p1,p2,vme,A,B,E,d,y):
    C=transporte(A,B,E,p1,p2)
    D=evolution_sir_cm(alpha,beta,vme,C[0],C[2],d,y)[0]
    E=evolution_sir_cm(alpha,beta,vme,C[1],C[2],d,y)[0]
    n,m=A.shape
    for i in range(n):
        for j in range(m):
            if C[0][i,j]==75:
                D[i,j]=75
            if C[1][i,j]==75:
                E[i,j]=75
            if C[2][i,j]==0:
                D[i,j]=3
                E[i,j]=3
    return [D,E,C[2]]

def evolution_SIR_m(alpha,beta,p1,p2,tf,vme,A,B,E,y):
    L1=[A]; L2=[B]; L3=[E]
    for i in range(1,tf):
        L1.append(evolution_sir_m(alpha,beta,p1,p2,vme,L1[i-1],L2[i-1],L3[i-1],i,y)[0])
        L2.append(evolution_sir_m(alpha,beta,p1,p2,vme,L1[i-1],L2[i-1],L3[i-1],i,y)[1])
        L3.append(evolution_sir_m(alpha,beta,p1,p2,vme,L1[i-1],L2[i-1],L3[i-1],i,y)[2])
    return [L1,L2,L3]

def SIR_m_model(alpha,beta,p1,p2,tf,vme,A,B,E,y):
    S=[]; I=[]; R=[]; D=[]           
    CI=np.zeros((tf,2))           
    CS=np.zeros((tf,2))           
    CR=np.zeros((tf,2)) 
    CD=np.zeros((tf,2))
    C=evolution_SIR_m(alpha,beta,p1,p2,tf,vme,A,B,E,y)
    for i in range(tf):
        M=superposicion(C[0][i],C[1][i])
        S.append(count_s(M))      
        I.append(count_i(M))   
        R.append(count_r(M))  
        D.append(count_d(M))
    for i in range(tf):           
        CS[i][0]=i; CS[i][1]=S[i]   
        CI[i][0]=i; CI[i][1]=I[i]   
        CR[i][0]=i; CR[i][1]=R[i]
        CD[i][0]=i; CD[i][1]=D[i]   
    return [CS,CR,CI,CD,S,I,R,D,C]

count_S(b17)

b17=initial_condition(0.6,b17)

ecv=[b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16,b17,b18,b19,b20,b21,b22,b23,b24,b25,b26,b27,b28,b29,b30,b31]

for i in range(len(ecv)):
    cv=superposicion(cv,ecv[i])

plt.imshow(color(cv),cmap="nipy_spectral", interpolation='nearest')

cvv=np.ones((80,71))
for i in range(80):
    for j in range(71):
        if cv[i,j]==-1:
            cvv[i,j]=75
        else: 
            cvv[i,j]=-1

plt.imshow(color(superposicion(cv,cvv)),cmap="nipy_spectral", interpolation='nearest')

E=edades_cv(cv)

D=[20,0,0,0,27,40,25,0,0,74,17,107,4,5,103,1,85,0,149,0,24,76,63,21,18,6,1,1,0,0,0,0,9,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0]
D1=[20]
for i in range(len(D)-1):
    D1.append(D1[i]+D[i+1])
Data=np.zeros((len(D),2))
Data1=np.zeros((len(D1),2))
for i in range(len(D1)):
    Data1[i,0]=i; Data1[i,1]=D1[i]/1782

plt.imshow(color(cv),cmap="nipy_spectral", interpolation='nearest')

def graph_sir_m(alpha,beta,p1,p2,tf,vme,A,B,E,y):   
    SIR=SIR_m_model(alpha,beta,p1,p2,tf,vme,A,B,E,y)      
    four_states_graph(SIR[0],SIR[2],SIR[1],SIR[3], "Modelo SIR con movimiento")

one_state_graph(Data1,"CV")

def norma(Data,I):
    m=0
    for i in range(len(Data)):
        m=m+(Data[i][1]-I[i][1])**2
        m=m**(1/2)
    return m

I=SIR_m_model(0.00504,0.486531,0.29,0.09,41,vme,cv,cvv,E,365)
two_states_graph(Data1,I[2],"Datos reales","Modelo en AC","CV")

norma(Data1,I)

I=SIR_m_model(0.00504,0.486531,0.29,0.09,41,vme,cv,cvv,E,365)
two_states_graph(Data1,I[2],"Datos reales","Modelo en AC","CV")

norma(Data1,I)

I=SIR_m_model(0.00504,0.486531,0.29,0.09,41,vme,cv,cvv,E,365)
two_states_graph(Data1,I[2],"Datos reales","Modelo en AC","CV")

two_states_graph(Data1,IP,"Datos reales","Modelo en AC","Covid en la Cárcel de Villavicencio")

norma(Data1,IP)

IP=np.zeros((80,2))
n=10
for i in range(n):
    I=SIR_m_model(0.00504,0.486531,0.29,0.09,80,vme,cv,cvv,E,365)
    for j in range(80):
        m=I[2][j][1]
        IP[j][1]=IP[j][1]+m
        IP[j][0]=j
for i in range(len(IP)):
    IP[i][1]=float(IP[i][1]/n)

one_state_graph(IP,"Pronostico para el mes de Julio")

len(IP)

one_state_graph(I[3],"Modelo en AC")

I[3][30]

"""## Simulación en Bogotá

### Generación del mapa
"""

Bogota=-np.ones((75,155))
Bogota=sm(4,50,10,5,Bogota); Bogota=sm(5,5,5,15,Bogota); Bogota=sm(5,3,6,18,Bogota)
Bogota=sm(5,3,5,27,Bogota); Bogota=sm(5,3,6,26,Bogota); Bogota=sm(5,5,5,33,Bogota)
Bogota=sm(8,1,6,14,Bogota); Bogota=sm(1,7,9,6,Bogota); Bogota=sm(5,3,7,20,Bogota)
Bogota=sm(5,30,8,22,Bogota); Bogota=sm(5,5,6,30,Bogota); Bogota=sm(5,1,7,38,Bogota)
Bogota=sm(5,1,7,46,Bogota); Bogota=sm(1,50,14,6,Bogota); Bogota=sm(3,50,15,8,Bogota)
Bogota=sm(1,50,18,9,Bogota); Bogota=sm(1,2,9,52,Bogota); Bogota=sm(10,5,12,55,Bogota)
Bogota=sm(10,1,13,60,Bogota); Bogota=sm(10,4,14,60,Bogota); Bogota=sm(10,2,15,64,Bogota)
Bogota=sm(10,3,16,66,Bogota); Bogota=sm(10,5,15,69,Bogota); Bogota=sm(10,3,14,71,Bogota)
Bogota=sm(10,1,15,74,Bogota); Bogota=sm(10,3,16,75,Bogota); Bogota=sm(10,5,18,78,Bogota)
Bogota=sm(10,3,17,83,Bogota); Bogota=sm(10,3,18,86,Bogota); Bogota=sm(10,2,19,89,Bogota)
Bogota=sm(10,2,20,91,Bogota); Bogota=sm(5,50,19,16,Bogota); Bogota=sm(5,50,21,12,Bogota)
Bogota=sm(3,70,22,10,Bogota); Bogota=sm(2,70,23,9,Bogota); Bogota=sm(1,70,24,8,Bogota)
Bogota=sm(2,70,25,7,Bogota); Bogota=sm(2,4,26,8,Bogota); Bogota=sm(2,2,27,9,Bogota)
Bogota=sm(1,70,27,12,Bogota); Bogota=sm(1,70,28,14,Bogota); Bogota=sm(1,70,29,15,Bogota)
Bogota=sm(1,70,30,17,Bogota); Bogota=sm(1,70,31,19,Bogota); Bogota=sm(1,70,32,21,Bogota)
Bogota=sm(6,60,32,21,Bogota); Bogota=sm(1,4,38,22,Bogota); Bogota=sm(1,1,39,23,Bogota)
Bogota=sm(1,5,38,26,Bogota); Bogota=sm(5,5,39,27,Bogota); Bogota=sm(4,1,40,26,Bogota)
Bogota=sm(3,1,41,25,Bogota); Bogota=sm(1,8,44,24,Bogota); Bogota=sm(1,8,44,24,Bogota)
Bogota=sm(1,8,45,25,Bogota); Bogota=sm(1,8,46,26,Bogota); Bogota=sm(1,8,47,27,Bogota)
Bogota=sm(1,8,48,28,Bogota); Bogota=sm(2,1,49,29,Bogota); Bogota=sm(1,5,49,30,Bogota)
Bogota=sm(15,5,34,32,Bogota); Bogota=sm(5,5,35,28,Bogota); Bogota=sm(20,5,31,33,Bogota)
Bogota=sm(30,5,22,34,Bogota); Bogota=sm(1,5,52,35,Bogota); Bogota=sm(1,5,53,36,Bogota)
Bogota=sm(1,2,54,37,Bogota); Bogota=sm(32,3,22,39,Bogota); Bogota=sm(1,5,49,30,Bogota)
Bogota=sm(1,5,49,32,Bogota); Bogota=sm(20,53,20,40,Bogota); Bogota=sm(35,1,20,42,Bogota)
Bogota=sm(36,1,20,43,Bogota); Bogota=sm(37,2,20,44,Bogota); Bogota=sm(36,1,20,46,Bogota)
Bogota=sm(35,1,20,47,Bogota); Bogota=sm(33,1,20,48,Bogota); Bogota=sm(2,3,50,49,Bogota)
Bogota=sm(5,42,40,51,Bogota); Bogota=sm(2,1,49,49,Bogota); Bogota=sm(8,2,40,49,Bogota)
Bogota=sm(6,2,40,50,Bogota); Bogota=sm(5,40,40,51,Bogota); Bogota=sm(6,40,40,53,Bogota)
Bogota=sm(7,30,40,56,Bogota); Bogota=sm(8,30,40,59,Bogota); Bogota=sm(9,30,40,62,Bogota)
Bogota=sm(10,25,40,64,Bogota); Bogota=sm(11,25,40,66,Bogota); Bogota=sm(16,25,40,67,Bogota)
Bogota=sm(2,25,55,65,Bogota); Bogota=sm(2,25,57,65,Bogota); Bogota=sm(2,25,56,64,Bogota)
Bogota=sm(2,5,58,62,Bogota); Bogota=sm(2,5,59,60,Bogota); Bogota=sm(2,4,60,58,Bogota)
Bogota=sm(5,25,58,67,Bogota); Bogota=sm(5,25,60,66,Bogota); Bogota=sm(1,23,65,64,Bogota)
Bogota=sm(2,15,66,69,Bogota); Bogota=sm(40,4,20,90,Bogota); Bogota=sm(41,1,19,94,Bogota)
Bogota=sm(40,1,20,95,Bogota); Bogota=sm(41,1,19,96,Bogota); Bogota=sm(40,1,20,97,Bogota)
Bogota=sm(40,1,20,98,Bogota); Bogota=sm(38,1,21,99,Bogota); Bogota=sm(5,2,55,100,Bogota)
Bogota=sm(3,2,58,102,Bogota); Bogota=sm(33,2,21,100,Bogota); Bogota=sm(33,2,20,102,Bogota)
Bogota=sm(36,4,19,104,Bogota); Bogota=sm(35,3,19,106,Bogota); Bogota=sm(2,3,19,109,Bogota)
Bogota=sm(31,3,22,109,Bogota); Bogota=sm(31,3,25,111,Bogota); Bogota=sm(32,1,25,114,Bogota)
Bogota=sm(34,1,25,115,Bogota); Bogota=sm(33,1,25,116,Bogota); Bogota=sm(1,1,58,117,Bogota)
Bogota=sm(1,1,58,116,Bogota); Bogota=sm(33,3,24,117,Bogota); Bogota=sm(5,2,51,120,Bogota)
Bogota=sm(26,1,24,120,Bogota); Bogota=sm(25,1,24,121,Bogota); Bogota=sm(3,1,52,122,Bogota)
Bogota=sm(1,1,54,123,Bogota); Bogota=sm(1,1,52,123,Bogota); Bogota=sm(23,1,24,122,Bogota)
Bogota=sm(21,3,24,123,Bogota); Bogota=sm(21,2,26,126,Bogota); Bogota=sm(21,2,28,128,Bogota)
Bogota=sm(17,5,30,130,Bogota); Bogota=sm(5,2,28,135,Bogota); Bogota=sm(12,2,35,135,Bogota)
Bogota=sm(5,2,27,136,Bogota); Bogota=sm(11,2,35,136,Bogota); Bogota=sm(5,5,26,137,Bogota)
Bogota=sm(10,2,35,137,Bogota); Bogota=sm(8,2,35,138,Bogota); Bogota=sm(6,3,35,139,Bogota)
Bogota=sm(6,6,36,140,Bogota); Bogota=sm(3,3,36,146,Bogota)
plt.imshow(color(Bogota),cmap="nipy_spectral", interpolation='nearest')

Bogota=initialcondition(0.001,Bogota)
plt.imshow(color(Bogota),cmap="nipy_spectral", interpolation='nearest')

heatmapsirI(1/14,2.5/14,30,Bogota)

BTA=sir(0.2,0.5,100,Bogota)[6]
for i in range(100):
  plt.imshow(color(BTA[i]),cmap="nipy_spectral", interpolation='nearest')
  plt.savefig('BTA'+str(i)+'.jpg')

img_Bogota = []
for i in range(100):
    img = cv2.imread('BTA'+str(i)+'.jpg')
    height, width, layers = img.shape
    size = (width,height)
    img_Bogota.append(img)

out = cv2.VideoWriter('Bogota.avi',cv2.VideoWriter_fourcc(*'DIVX'), 15, size)
 
for i in range(len(img_Bogota)):
    out.write(img_Bogota[i])
out.release()

grafsir(0.2,0.5,100,Bogota)

"""## References

[1] Diego de Pereda Sebastian. Modelización matemática de la difusión de una epidemia depeste porcina entre granjas, 2010.

[2] IDM: SEIR and SEIRS models, https://institutefordiseasemodeling.github.io/Documentation/general/model-seir.html

[3] David Alejandro Reyes Gomez.Descripción y Aplicaciones de los Autómatas celulares, 2011.

[4] Genaro Juarez Martinez.Introducción a la simulación con autómata celular, 2006.

[5]Jorge Andres Ibañez Huertas.Simulación epidemiológica usando autómatas celulares, 2019.

# Prubas transporte
"""

def sism(alpha,beta,tf,A,B,pr):
  La=[A]; Lb=[B]
  L=[superposicion(A,B)]
  for i in range(1,tf):
    La.append(evosis1(alpha,beta,La[i-1]))
    Lb.append(evosis1(alpha,beta,Lb[i-1]))
    trans=transporte(La[i],Lb[i],pr)
    La[i]=trans[0]; Lb[i]=trans[1]
    L.append(superposicion(La[i],Lb[i]))
  return L



n,m=p2.shape
for i in range(n):
  for j in range(m):
    if p2[i,j]==0:
      p2[i,j]=3

K1=evosis1(0.2,0.5,trans1[0])
K2=evosis1(0.2,0.5,trans1[1])
plt.imshow(color(superposicion(K1,K2)),cmap="nipy_spectral", interpolation='nearest')

SISM=sism(0.2,0.5,30,K1,K2,0.5)
plt.imshow(color(SISM[1]),cmap="nipy_spectral", interpolation='nearest')



Prueba=sism(0.2,0.5,15,K1,K2,0.5)
for i in range(15):
  plt.imshow(color(Prueba[i]),cmap="nipy_spectral", interpolation='nearest')
  plt.savefig('Pr'+str(i)+'.jpg')

img_Pr = []
for i in range(15):
    img = cv2.imread('Pr'+str(i)+'.jpg')
    height, width, layers = img.shape
    size = (width,height)
    img_Pr.append(img)

out = cv2.VideoWriter('Pr.avi',cv2.VideoWriter_fourcc(*'DIVX'), 15, size)
 
for i in range(len(img_Pr)):
    out.write(img_Pr[i])
out.release()

def reglas11(alpha,beta,V):                               
  I = sumaI(V); S = sumaS(V); Va = sumaV(V)               
  B = np.zeros((3,3))                                     
  r = random.randint(0,100)                               
  for i in range(3):                                      
    for j in range(3):                                    
      B[i][j] = V[i][j]                                   
  if V[1][1] != -1 and V[1][1] != 3:                                       
    if I > 0:                                             
      if I <= S and r >= (I/(8 - Va))*(beta/alpha) * 100: 
        B[1][1] = 0     
      else:                                               
        B[1][1] = 1
    else:
      B[1][1] = V[1][1]
  elif V[1][1] == -1:                                                   
    B[1][1] = -1
  else:
    B[1][1] = 3
  return B[1][1]

def evosis1(alpha,beta,U):         #Regla base de evolucion en U de parametros alpha y beta
  n,m = U.shape                   #dim(U)=nm
  B = np.zeros((n + 2,m + 2))     #B será un arreglo nulo sobre el cual se sobreescribiran los datos de U
  C = np.zeros((n,m))             #C será el arreglo que guardará los datos luego de aplicar la regla base de evolución 
  I = contari(U)                  #Se aplicará la regla siempre y cuando existan individuos infectados
  for i in range(n):                              
    for j in range(m):
      B[i + 1][j + 1] = U[i][j]   #Se sobreescriben los datos de U sobre B
  for i in range(n):
    for j in range(m):
      if I > 0:                                             #Si hay individuos infectados en el sistema
        C[i][j] = reglas11(alpha,beta,genarray(B,i+1,j+1))   #Aplique la regla base de evolución local a U y guarde los valores en C 
      else:                                                 #Si no hay individuos infectados
        C[i][j] = U[i][j]                                   #La regla base de evolución actua como la función identica sobre el sistema
  return C

def evoSIS1(alpha,beta,tf,A):           
  L = [A]                               
  i = 0                                 
  while i <= tf:                        
    i = i + 1                           
    L.append(evosis1(alpha,beta,L[i-1])) 
  return L

def sis1(alpha,beta,tf,A):                       #Modelo SIS
  S = []; I = []                                #S e I guardan la cantidad de individuos pertenecientes a los estados S e I por cada iteración 
  CI = np.zeros((tf,2)); CS = np.zeros((tf,2))  #CS y CI nos permitiran graficar los datos de S e I
  B = evoSIS(alpha,beta,tf,A)                   #Calculamos la evolución inicial del sistema A hasta el tiempo tf
  for j in range(tf):                           #Para cada iteración defina
    M = B[j]                                    #M será la evolución en el instante t=i
    S.append(contarsn(M))                       #Añadimos el promedio de susceptibles en M a S 
    I.append(contarin(M))                       #Añadimos el promedio de infectados en M a I                           
  for i in range(tf):                           #Para cada instante i hasta tf defina
    CS[i][0] = i; CS[i][1] = S[i]               #CS[i]=(i,S[i]) -> (tiempo i, cantidad de susceptibles en el tiempo i)
    CI[i][0] = i; CI[i][1] = I[i]               #CI[i]=(i,I[i]) -> (tiempo i, cantidad de infectados en el tiempo i)
  return [CS,CI,S,I,B]